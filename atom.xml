<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>数据安全技术研究</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.yindex.org/"/>
  <updated>2020-02-26T12:31:13.064Z</updated>
  <id>https://blog.yindex.org/</id>
  
  <author>
    <name>yindex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式快照算法 Chandy-Lamport</title>
    <link href="https://blog.yindex.org/2020/02/15/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7%E7%AE%97%E6%B3%95%20Chandy-Lamport/"/>
    <id>https://blog.yindex.org/2020/02/15/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7%E7%AE%97%E6%B3%95%20Chandy-Lamport/</id>
    <published>2020-02-15T16:12:31.000Z</published>
    <updated>2020-02-26T12:31:13.064Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>A snapshot algorithm is used to create a consistent snapshot of the global state of a distributed system. Due to the lack of globally shared memory and a global clock, the isn’t trivially possible.</p><h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h1><p>Chandy-Lamport algorithm is named by two author’s name. One of them, Lamport, the author of Paxos.</p><blockquote><p>The distributed snapshot algorithm described here came about when I  visited Chandy, who was then at the University of Texas in Austin. He  posed the problem to me over dinner, but we had both had too much wine  to think about it right then. The next morning, in the shower, I came up with the solution. When I arrived at Chandy’s office, he was waiting  for me with the same solution. I consider the algorithm to be a  straightforward application of the basic ideas from Time, Clocks and the Ordering of Events in a Distributed System. </p></blockquote><h1 id="2-Global-Snapshot"><a href="#2-Global-Snapshot" class="headerlink" title="2. Global Snapshot"></a>2. Global Snapshot</h1><h1 id="3-Chandy-Lamport"><a href="#3-Chandy-Lamport" class="headerlink" title="3. Chandy-Lamport"></a>3. Chandy-Lamport</h1><h1 id="4-Experiment"><a href="#4-Experiment" class="headerlink" title="4. Experiment"></a>4. Experiment</h1><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;A snapshot algori
      
    
    </summary>
    
    
      <category term="flink" scheme="https://blog.yindex.org/categories/flink/"/>
    
    
      <category term="分布式快照" scheme="https://blog.yindex.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%AB%E7%85%A7/"/>
    
      <category term="flink" scheme="https://blog.yindex.org/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>LVS后端GO-Web获取用户IP</title>
    <link href="https://blog.yindex.org/2019/07/10/go-lvs-toa-ipv4/"/>
    <id>https://blog.yindex.org/2019/07/10/go-lvs-toa-ipv4/</id>
    <published>2019-07-10T16:12:31.000Z</published>
    <updated>2020-02-26T12:31:13.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-问题"><a href="#0x01-问题" class="headerlink" title="0x01. 问题"></a>0x01. 问题</h2><p>最近写了个对外的ti接口,测试时发现获取到的用户ip都是lvs的ip. 咨询hulk同事LVS是FULLNAT模式,宿主机器需要安装toa.然而安装完toa后依旧没有解决问题.z在宿主机器上查看go-web监听和链接情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -pant | grep ti</span><br></pre></td></tr></table></figure><p>发现go gin框架默认以tcp6监听服务，通过查询资料得知toa仅支持tcp4, 那么就需要修改下源代码让服务监听tcp4.</p><h2 id="0x02-查看gin源码"><a href="#0x02-查看gin源码" class="headerlink" title="0x02. 查看gin源码"></a>0x02. 查看gin源码</h2><p>想看看gin是如何进行tcp监听的，查看gin.go代码289行发现，gin框架是使用go原生http.ListenAndServe启动的web服务.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">Run</span><span class="params">(addr ...<span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; debugPrintError(err) &#125;()</span><br><span class="line"></span><br><span class="line">address := resolveAddress(addr)</span><br><span class="line">debugPrint(<span class="string">"Listening and serving HTTP on %s\n"</span>, address)</span><br><span class="line">err = http.ListenAndServe(address, engine)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看ListenAndServe代码得知，go的net/http就是以默认tcp6启动的http服务.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line">&#125;</span><br><span class="line">addr := srv.Addr</span><br><span class="line"><span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">addr = <span class="string">":http"</span></span><br><span class="line">&#125;</span><br><span class="line">ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此想通过gin的某些魔法设置从而以tcp4监听的想法是不可能了，并且gin的issue中也说明了这一点:</p><blockquote><p><a href="https://github.com/gin-gonic/gin/issues/667" target="_blank" rel="noopener">https://github.com/gin-gonic/gin/issues/667</a></p></blockquote><h2 id="0x03-手动监听"><a href="#0x03-手动监听" class="headerlink" title="0x03. 手动监听"></a>0x03. 手动监听</h2><p>通过手动启动tcp监听，然后配置handler来实现，tcp4启动的web服务.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tcp4Router <span class="keyword">struct</span> &#123;</span><br><span class="line">Handler http.Handler</span><br><span class="line">listener net.Listener</span><br><span class="line">server *http.Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tcp4Router)</span><span class="title">Run</span><span class="params">(addr <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">t.server = &amp;http.Server&#123;Addr:addr, Handler:t.Handler&#125;</span><br><span class="line"></span><br><span class="line">t.listener, err = net.Listen(<span class="string">"tcp4"</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = t.server.Serve(t.listener)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-最后"><a href="#0x04-最后" class="headerlink" title="0x04. 最后"></a>0x04. 最后</h2><p>  生命在于折腾，在于学习…</p><h2 id="致谢学习"><a href="#致谢学习" class="headerlink" title="致谢学习"></a>致谢学习</h2><p><a href="https://blog.csdn.net/achejq/article/details/73733920" target="_blank" rel="noopener">https://blog.csdn.net/achejq/article/details/73733920</a><br><a href="https://cloud.tencent.com/document/product/1022/31524" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/1022/31524</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-问题&quot;&gt;&lt;a href=&quot;#0x01-问题&quot; class=&quot;headerlink&quot; title=&quot;0x01. 问题&quot;&gt;&lt;/a&gt;0x01. 问题&lt;/h2&gt;&lt;p&gt;最近写了个对外的ti接口,测试时发现获取到的用户ip都是lvs的ip. 咨询hulk同事LVS是
      
    
    </summary>
    
    
      <category term="后端开发" scheme="https://blog.yindex.org/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="go" scheme="https://blog.yindex.org/tags/go/"/>
    
      <category term="lvs" scheme="https://blog.yindex.org/tags/lvs/"/>
    
      <category term="tcp6" scheme="https://blog.yindex.org/tags/tcp6/"/>
    
  </entry>
  
  <entry>
    <title>NSQ代码阅读与分析之inFlightPqueue与inFlightPqueue</title>
    <link href="https://blog.yindex.org/2019/04/20/2019-04-20-NSQ-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E5%88%86%E6%9E%90-inFlightPqueue%E5%92%8CPriorityQueue/"/>
    <id>https://blog.yindex.org/2019/04/20/2019-04-20-NSQ-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E5%88%86%E6%9E%90-inFlightPqueue%E5%92%8CPriorityQueue/</id>
    <published>2019-04-20T00:00:00.000Z</published>
    <updated>2020-02-26T12:31:13.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ul><li><a href="https://nsq.io/clients/tcp_protocol_spec.html" target="_blank" rel="noopener">https://nsq.io/clients/tcp_protocol_spec.html</a></li><li><a href="https://github.com/nsqio/nsq" target="_blank" rel="noopener">https://github.com/nsqio/nsq</a></li><li><a href="https://blog.csdn.net/skh2015java/article/details/83419493" target="_blank" rel="noopener">https://blog.csdn.net/skh2015java/article/details/83419493</a></li><li><a href="https://blog.csdn.net/skh2015java/article/details/83416045" target="_blank" rel="noopener">https://blog.csdn.net/skh2015java/article/details/83416045</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ref&quot;&gt;&lt;a href=&quot;#Ref&quot; class=&quot;headerlink&quot; title=&quot;Ref&quot;&gt;&lt;/a&gt;Ref&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nsq.io/clients/tcp_protocol_spec.html&quot; targ
      
    
    </summary>
    
    
      <category term="中间件" scheme="https://blog.yindex.org/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="golang" scheme="https://blog.yindex.org/tags/golang/"/>
    
      <category term="nsq" scheme="https://blog.yindex.org/tags/nsq/"/>
    
      <category term="消息队列" scheme="https://blog.yindex.org/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="中间件" scheme="https://blog.yindex.org/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="消息投递" scheme="https://blog.yindex.org/tags/%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>NSQ代码阅读与分析之TOPIC</title>
    <link href="https://blog.yindex.org/2019/04/20/2019-04-20-NSQ-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E5%88%86%E6%9E%90-TOPIC/"/>
    <id>https://blog.yindex.org/2019/04/20/2019-04-20-NSQ-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E5%88%86%E6%9E%90-TOPIC/</id>
    <published>2019-04-20T00:00:00.000Z</published>
    <updated>2020-02-26T12:31:13.064Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>NSQ的Topic类型在<code>nsq/nsqd/topic.go中</code>定义，该文件中实现了Topic工厂方法，Topc状态管理、Channel(此channel非彼channel，该channel是nsq消费者通道)管理、消息写入、消息推送、落盘等.</p><h2 id="Topic类型定义"><a href="#Topic类型定义" class="headerlink" title="Topic类型定义"></a>Topic类型定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Topic <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 64bit atomic vars need to be first for proper alignment on 32bit platforms</span></span><br><span class="line">messageCount <span class="keyword">uint64</span></span><br><span class="line">    <span class="comment">//消息总大小</span></span><br><span class="line">messageBytes <span class="keyword">uint64</span></span><br><span class="line">sync.RWMutex</span><br><span class="line">    <span class="comment">//topic 名称</span></span><br><span class="line">name              <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//消费者通道映射表</span></span><br><span class="line">channelMap        <span class="keyword">map</span>[<span class="keyword">string</span>]*Channel</span><br><span class="line">    <span class="comment">//后端落盘队列: 临时topic设置了伪落盘</span></span><br><span class="line">backend           BackendQueue</span><br><span class="line">    <span class="comment">//消息内存队列（chan)</span></span><br><span class="line">memoryMsgChan     <span class="keyword">chan</span> *Message</span><br><span class="line">startChan         <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">exitChan          <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">channelUpdateChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">waitGroup         util.WaitGroupWrapper</span><br><span class="line">exitFlag          <span class="keyword">int32</span></span><br><span class="line">idFactory         *guidFactory</span><br><span class="line">ephemeral      <span class="keyword">bool</span></span><br><span class="line">deleteCallback <span class="function"><span class="keyword">func</span><span class="params">(*Topic)</span></span></span><br><span class="line">deleter        sync.Once</span><br><span class="line">paused    <span class="keyword">int32</span></span><br><span class="line">pauseChan <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 节点上下文,包含节点各种信息</span></span><br><span class="line">ctx *context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Topic类型中定义Topic所必须的消息内存存储队列通道(golang channel)、落盘队列、以及消费者消费通道和一起其他的状态管理参数等.</p><h2 id="Topic创建"><a href="#Topic创建" class="headerlink" title="Topic创建"></a>Topic创建</h2><p>通过<code>func NewTopic(topicName string, ctx *context, deleteCallback func(*Topic)) *Topic</code>工厂方法创建Topic实例，代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTopic</span><span class="params">(topicName <span class="keyword">string</span>, ctx *context, deleteCallback <span class="keyword">func</span>(*Topic)</span>) *<span class="title">Topic</span></span> &#123;</span><br><span class="line">t := &amp;Topic&#123;</span><br><span class="line">name:              topicName,</span><br><span class="line">channelMap:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Channel),</span><br><span class="line">memoryMsgChan:     <span class="built_in">make</span>(<span class="keyword">chan</span> *Message, ctx.nsqd.getOpts().MemQueueSize),</span><br><span class="line">startChan:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">exitChan:          <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">channelUpdateChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">ctx:               ctx,</span><br><span class="line">paused:            <span class="number">0</span>,</span><br><span class="line">pauseChan:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">deleteCallback:    deleteCallback,</span><br><span class="line">idFactory:         NewGUIDFactory(ctx.nsqd.getOpts().ID),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> strings.HasSuffix(topicName, <span class="string">"#ephemeral"</span>) &#123;</span><br><span class="line">t.ephemeral = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 不干活的后端落盘</span></span><br><span class="line">t.backend = newDummyBackendQueue()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dqLogf := <span class="function"><span class="keyword">func</span><span class="params">(level diskqueue.LogLevel, f <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">opts := ctx.nsqd.getOpts()</span><br><span class="line">lg.Logf(opts.Logger, opts.LogLevel, lg.LogLevel(level), f, args...)</span><br><span class="line">&#125;</span><br><span class="line">t.backend = diskqueue.New(</span><br><span class="line">topicName,</span><br><span class="line">ctx.nsqd.getOpts().DataPath,</span><br><span class="line">ctx.nsqd.getOpts().MaxBytesPerFile,</span><br><span class="line"><span class="keyword">int32</span>(minValidMsgLength),</span><br><span class="line"><span class="keyword">int32</span>(ctx.nsqd.getOpts().MaxMsgSize)+minValidMsgLength,</span><br><span class="line">ctx.nsqd.getOpts().SyncEvery,</span><br><span class="line">ctx.nsqd.getOpts().SyncTimeout,</span><br><span class="line">dqLogf,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">t.waitGroup.Wrap(t.messagePump)</span><br><span class="line">t.ctx.nsqd.Notify(t)</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先直接创建了一个Topic对象、初始化默认值等.而后判断消息topic是否为临时topic确定落盘队列性质.若为临时topic则newDummyBackenQueue方法给Topic.backend配置伪落盘队列.通过查看该方法实现可知,<code>newDummyBackenQueue</code>创建的落盘队列无任何功能,提供的接口都是空操作.若非临时Topic,则创建磁盘落盘队列<code>diskQueue</code>.</p><p>Topic创建完成随即启动<code>messagePump</code>, 该方法从磁盘或内存中竞争选择一条消息写入到订阅该消息的消费者通道中.  从<code>messagePump</code>方法注释中也可以看出,消息落盘后将不能保证消息消费顺序. </p><p>同时调用<code>Notify</code>方法将该Topic信息通知给对应的nsqlookupd.</p><h2 id="func-t-Topic-PutMessage-m-Message-error-方法"><a href="#func-t-Topic-PutMessage-m-Message-error-方法" class="headerlink" title="func (t *Topic) PutMessage(m *Message) error 方法"></a>func (t *Topic) PutMessage(m *Message) error 方法</h2><p><code>PutMessage</code>方法实现了消息写入(http/tcp的pub接口就是调用该方法实现).<code>PutMessage</code>方法调用<code>put</code>方法写入消息.<code>put</code>方法尝试向 topic内存通道(go channel)扇入消息,若此时通道已经写满,那么该case语句将不能被执行. 于是执行default分支将消息写入到backendQueue存储到磁盘中.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">PutMessage</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">t.RLock()</span><br><span class="line"><span class="keyword">defer</span> t.RUnlock()</span><br><span class="line"><span class="keyword">if</span> atomic.LoadInt32(&amp;t.exitFlag) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br><span class="line">err := t.put(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子增加消息数量</span></span><br><span class="line">atomic.AddUint64(&amp;t.messageCount, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 原则增加消息总大小</span></span><br><span class="line">atomic.AddUint64(&amp;t.messageBytes, <span class="keyword">uint64</span>(<span class="built_in">len</span>(m.Body)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">put</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">//若通道已满则执行default分支</span></span><br><span class="line"><span class="keyword">case</span> t.memoryMsgChan &lt;- m:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">b := bufferPoolGet()</span><br><span class="line">err := writeMessageToBackend(b, m, t.backend)</span><br><span class="line">bufferPoolPut(b)</span><br><span class="line">t.ctx.nsqd.SetHealth(err)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.ctx.nsqd.logf(LOG_ERROR,</span><br><span class="line"><span class="string">"TOPIC(%s) ERROR: failed to write message to backend - %s"</span>,</span><br><span class="line">t.name, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="func-t-Topic-messagePump-方法"><a href="#func-t-Topic-messagePump-方法" class="headerlink" title="func (t *Topic) messagePump()方法"></a>func (t *Topic) messagePump()方法</h2><blockquote><p>messagePump selects over the in-memory and backend queue and<br>writes messages to every channel for this topic</p></blockquote><p>上述是<code>messagePump</code>方法的注释,可以看出<code>messagePump</code>方法主要功能为:从内存通道或磁盘中竞争选择消息写入到订阅通道中.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">messagePump</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> msg *Message</span><br><span class="line"><span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> chans []*Channel</span><br><span class="line"><span class="keyword">var</span> memoryMsgChan <span class="keyword">chan</span> *Message</span><br><span class="line"><span class="keyword">var</span> backendChan <span class="keyword">chan</span> []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do not pass messages before Start(), but avoid blocking Pause() or GetChannel()</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.channelUpdateChan:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.pauseChan:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.exitChan:</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line"><span class="keyword">case</span> &lt;-t.startChan:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">t.RLock()</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> t.channelMap &#123;</span><br><span class="line">chans = <span class="built_in">append</span>(chans, c)</span><br><span class="line">&#125;</span><br><span class="line">t.RUnlock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(chans) &gt; <span class="number">0</span> &amp;&amp; !t.IsPaused() &#123;</span><br><span class="line">memoryMsgChan = t.memoryMsgChan</span><br><span class="line">backendChan = t.backend.ReadChan()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main message loop</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg = &lt;-memoryMsgChan:</span><br><span class="line"><span class="keyword">case</span> buf = &lt;-backendChan:</span><br><span class="line">msg, err = decodeMessage(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.ctx.nsqd.logf(LOG_ERROR, <span class="string">"failed to decode message - %s"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.channelUpdateChan:</span><br><span class="line">chans = chans[:<span class="number">0</span>]</span><br><span class="line">t.RLock()</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> t.channelMap &#123;</span><br><span class="line">chans = <span class="built_in">append</span>(chans, c)</span><br><span class="line">&#125;</span><br><span class="line">t.RUnlock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(chans) == <span class="number">0</span> || t.IsPaused() &#123;</span><br><span class="line">memoryMsgChan = <span class="literal">nil</span></span><br><span class="line">backendChan = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">memoryMsgChan = t.memoryMsgChan</span><br><span class="line">backendChan = t.backend.ReadChan()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.pauseChan:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(chans) == <span class="number">0</span> || t.IsPaused() &#123;</span><br><span class="line">memoryMsgChan = <span class="literal">nil</span></span><br><span class="line">backendChan = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">memoryMsgChan = t.memoryMsgChan</span><br><span class="line">backendChan = t.backend.ReadChan()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.exitChan:</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, channel := <span class="keyword">range</span> chans &#123;</span><br><span class="line">chanMsg := msg</span><br><span class="line"><span class="comment">// copy the message because each channel</span></span><br><span class="line"><span class="comment">// needs a unique instance but...</span></span><br><span class="line"><span class="comment">// fastpath to avoid copy if its the first channel</span></span><br><span class="line"><span class="comment">// (the topic already created the first copy)</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">chanMsg = NewMessage(msg.ID, msg.Body)</span><br><span class="line">chanMsg.Timestamp = msg.Timestamp</span><br><span class="line">chanMsg.deferred = msg.deferred</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> chanMsg.deferred != <span class="number">0</span> &#123;</span><br><span class="line">channel.PutMessageDeferred(chanMsg, chanMsg.deferred)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">err := channel.PutMessage(chanMsg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.ctx.nsqd.logf(LOG_ERROR,</span><br><span class="line"><span class="string">"TOPIC(%s) ERROR: failed to put msg(%s) to channel(%s) - %s"</span>,</span><br><span class="line">t.name, msg.ID, channel.name, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">t.ctx.nsqd.logf(LOG_INFO, <span class="string">"TOPIC(%s): closing ... messagePump"</span>, t.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>messagePump</code>方法启动后,必须调用<code>Start()</code>方法:</p><blockquote><p>do not pass messages before Start(), but avoid blocking Pause() or GetChannel()</p></blockquote><p><code>messagePump</code>进入主消息循环, 此处是一个<code>select case</code>操作,竞争执行,其中有5个竞争条件.</p><ul><li><ol><li>msg  =  &lt;- memoryMsgChan</li></ol></li><li><ol start="2"><li>buf  = &lt;- backendChan</li></ol></li><li><ol start="3"><li>&lt;- t.channelUpdateChan</li></ol></li><li><ol start="4"><li>&lt;- t.pauseChan</li></ol></li><li><ol start="5"><li>&lt;- t.exitChan</li></ol></li></ul><p>通过竞争条件看出,topic启动后若有新消费者接入,及<code>&lt;- t.channelUpdateChan</code>分支能够执行,该分支操作将更新消费者订阅通道.</p><p>若磁盘和内存通道中都存在消息,那么条件1和条件2将竞争执行(谁抢到算谁的),因此消息一旦落入磁盘将不在保证消费顺序.</p><p><strong>消息写入订阅通道</strong></p><p>在源码topic.go:314行, Topic遍历订阅通道,并将消息写入到消费者通道中.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">    chanMsg = NewMessage(msg.ID, msg.Body)</span><br><span class="line">    chanMsg.Timestamp = msg.Timestamp</span><br><span class="line">    chanMsg.deferred = msg.deferred</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> chanMsg.deferred != <span class="number">0</span> &#123;</span><br><span class="line">    channel.PutMessageDeferred(chanMsg, chanMsg.deferred)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">err := channel.PutMessage(chanMsg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.ctx.nsqd.logf(LOG_ERROR,</span><br><span class="line">                    <span class="string">"TOPIC(%s) ERROR: failed to put msg(%s) to channel(%s) - %s"</span>,</span><br><span class="line">                    t.name, msg.ID, channel.name, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过消息Message类型中<code>deferred</code>类型判断该消息是否为延迟消息,若为延迟消息则写入消费者通道的延迟队列中.否则写入到消费者消费队列中.</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ul><li><a href="https://nsq.io/clients/tcp_protocol_spec.html" target="_blank" rel="noopener">https://nsq.io/clients/tcp_protocol_spec.html</a></li><li><a href="https://github.com/nsqio/nsq" target="_blank" rel="noopener">https://github.com/nsqio/nsq</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;p&gt;NSQ的Topic类型在&lt;code&gt;nsq/nsqd/topic.go中&lt;/code&gt;定义，该文件中实现了Topic工厂方法，Topc状态管理、Channel(此channel非彼channel，该channel是nsq消费者通道)管理、消息写入
      
    
    </summary>
    
    
      <category term="中间件" scheme="https://blog.yindex.org/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="golang" scheme="https://blog.yindex.org/tags/golang/"/>
    
      <category term="nsq" scheme="https://blog.yindex.org/tags/nsq/"/>
    
      <category term="消息队列" scheme="https://blog.yindex.org/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="中间件" scheme="https://blog.yindex.org/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="topic" scheme="https://blog.yindex.org/tags/topic/"/>
    
  </entry>
  
  <entry>
    <title>NSQ代码阅读与分析之Channel</title>
    <link href="https://blog.yindex.org/2019/04/15/2019-04-20-NSQ-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E5%88%86%E6%9E%90-Channel/"/>
    <id>https://blog.yindex.org/2019/04/15/2019-04-20-NSQ-%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E5%88%86%E6%9E%90-Channel/</id>
    <published>2019-04-15T00:00:00.000Z</published>
    <updated>2020-02-26T12:31:13.064Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>此channel非彼channel,只是跟golang的channel同名而已,它是NSQ消费者订阅特定Topic的一种抽象.nsqd抽到生产者push的message后,会遍历当前topic下所有消费者channel并深度拷贝message下发到所有消费这channel中.并且同意个消费通道只会被投递一次.其中nsqd的deferred message在此实现.下图是nsq官网的一个消息流向图.</p><p><img src="/img/nsq.gif" alt="nsq.gif"></p><h2 id="channel创建于初始化"><a href="#channel创建于初始化" class="headerlink" title="channel创建于初始化"></a>channel创建于初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChannel</span><span class="params">(topicName <span class="keyword">string</span>, channelName <span class="keyword">string</span>, ctx *context,</span></span></span><br><span class="line"><span class="function"><span class="params">deleteCallback <span class="keyword">func</span>(*Channel)</span>) *<span class="title">Channel</span></span> &#123;</span><br><span class="line"></span><br><span class="line">c := &amp;Channel&#123;</span><br><span class="line">topicName:      topicName,</span><br><span class="line">name:           channelName,</span><br><span class="line">memoryMsgChan:  <span class="built_in">make</span>(<span class="keyword">chan</span> *Message, ctx.nsqd.getOpts().MemQueueSize),</span><br><span class="line">clients:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]Consumer),</span><br><span class="line">deleteCallback: deleteCallback,</span><br><span class="line">ctx:            ctx,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ctx.nsqd.getOpts().E2EProcessingLatencyPercentiles) &gt; <span class="number">0</span> &#123;</span><br><span class="line">c.e2eProcessingLatencyStream = quantile.New(</span><br><span class="line">ctx.nsqd.getOpts().E2EProcessingLatencyWindowTime,</span><br><span class="line">ctx.nsqd.getOpts().E2EProcessingLatencyPercentiles,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.initPQ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> strings.HasSuffix(channelName, <span class="string">"#ephemeral"</span>) &#123;</span><br><span class="line">c.ephemeral = <span class="literal">true</span></span><br><span class="line">c.backend = newDummyBackendQueue()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dqLogf := <span class="function"><span class="keyword">func</span><span class="params">(level diskqueue.LogLevel, f <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">opts := ctx.nsqd.getOpts()</span><br><span class="line">lg.Logf(opts.Logger, opts.LogLevel, lg.LogLevel(level), f, args...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// backend names, for uniqueness, automatically include the topic...</span></span><br><span class="line">backendName := getBackendName(topicName, channelName)</span><br><span class="line">c.backend = diskqueue.New(</span><br><span class="line">backendName,</span><br><span class="line">ctx.nsqd.getOpts().DataPath,</span><br><span class="line">ctx.nsqd.getOpts().MaxBytesPerFile,</span><br><span class="line"><span class="keyword">int32</span>(minValidMsgLength),</span><br><span class="line"><span class="keyword">int32</span>(ctx.nsqd.getOpts().MaxMsgSize)+minValidMsgLength,</span><br><span class="line">ctx.nsqd.getOpts().SyncEvery,</span><br><span class="line">ctx.nsqd.getOpts().SyncTimeout,</span><br><span class="line">dqLogf,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.ctx.nsqd.Notify(c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewChannel</code>工厂方法首先根据topicName, channelName创建了一个<code>Channel</code>类型类型实例,并初始化memoryMsgchan(内存channel)和一个消费者map.然后调用initPQ方法初始化其他参数.</p><p>若当前channel为临时channel,则创建一个伪后端落盘队列.否则通过<code>diskqueue.New</code>方法创建一个后端落盘队列.</p><p>最后调用<code>c.ctx.nsqd.Notify(c)</code>将该channel通知给当前集群的nsqlookupd.</p><p>###channel退出与释放</p><p>有创建channel就有对应的删除channel方法.源码<code>nsqd/channel.go:152</code>处可以看到该方法被完全锁保护,因此channel退出方法不能并发执行.</p><p>channel是消费者订阅通道,因此channel退出前需要关闭对应的消费者订阅连接.<code>nsqd/channel.go:169</code>位置通过读写锁保护,因此channel在退出时不允许新的消费着在创建连接.</p><p>最后将该channel中剩余的内容写入到磁盘.</p><h3 id="写入消息PutMessage"><a href="#写入消息PutMessage" class="headerlink" title="写入消息PutMessage"></a>写入消息PutMessage</h3><p>PutMessage通过调用<code>put</code>方法写入到内存或者磁盘中.其中put方法实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">put</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c.memoryMsgChan &lt;- m:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">b := bufferPoolGet()</span><br><span class="line">err := writeMessageToBackend(b, m, c.backend)</span><br><span class="line">bufferPoolPut(b)</span><br><span class="line">c.ctx.nsqd.SetHealth(err)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.ctx.nsqd.logf(LOG_ERROR, <span class="string">"CHANNEL(%s): failed to write message to backend - %s"</span>,</span><br><span class="line">c.name, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果channel的内存通道未满则将消息写入到内存通道中(Channel.memoryMsgChan)否则执行默认分支写入到后端磁盘队列(如果是临时channel这部分操作将是无效操作). 若写磁盘出错会调用setHealth设置当前节点健康状态.</p><h3 id="读-写延迟消息PutMessageDeferred"><a href="#读-写延迟消息PutMessageDeferred" class="headerlink" title="读/写延迟消息PutMessageDeferred"></a>读/写延迟消息PutMessageDeferred</h3><p><code>PutMessageDeferred</code>通过调用<code>StartDeferredTimeout(msg, timeout)</code>实现.其中timeout为该消息到期时间. <code>StartDeferredTimeout</code>方法实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">StartDeferredTimeout</span><span class="params">(msg *Message, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">absTs := time.Now().Add(timeout).UnixNano()</span><br><span class="line">item := &amp;pqueue.Item&#123;Value: msg, Priority: absTs&#125;</span><br><span class="line">err := c.pushDeferredMessage(item)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">c.addToDeferredPQ(item)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先计算出到期时间的时间戳,并将该事件戳设置到<code>Item</code>类型<code>nsqd/channel.go:441</code>的Priority字段.通过<code>addToDeferredPQ</code>方法<code>nsqd/channel.go:446</code> 将包含消延迟消息的Item添加到当前channel的deferredPQ字段. deferredPQ是一个pqueue.PriorityQueue类型,该类型是一个小根堆优先队列,也就是Priority值越小优先级越高所以时间戳越小越靠前.</p><p><strong>processDeferredQueue</strong>方法是处理延迟消息的消息循环,它的代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">processDeferredQueue</span><span class="params">(t <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">c.exitMutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.exitMutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.Exiting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dirty := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c.deferredMutex.Lock()</span><br><span class="line">item, _ := c.deferredPQ.PeekAndShift(t)</span><br><span class="line">c.deferredMutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line">&#125;</span><br><span class="line">dirty = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">msg := item.Value.(*Message)</span><br><span class="line">_, err := c.popDeferredMessage(msg.ID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line">&#125;</span><br><span class="line">c.put(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line"><span class="keyword">return</span> dirty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环体中,通过调用<code>c.deferredPQ.PeekAndShift(t)</code>扇出一条符合条件的消息.其中t为当前事件戳.那么怎么才算符合条件呢?查看<code>PeekAndShift</code>代码知道只有消息的优先级(事件戳)大于当前时间戳才算符合.</p><p>最后将扇出的消息投递回普通的消费者订阅通道(这块比较棒,代码复用不在重复发送逻辑).</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">PeekAndShift</span><span class="params">(max <span class="keyword">int64</span>)</span> <span class="params">(*Item, <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pq.Len() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">item := (*pq)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> item.Priority &gt; max &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, item.Priority - max</span><br><span class="line">&#125;</span><br><span class="line">heap.Remove(pq, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> item, <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么不是大于等于呢?</p></blockquote><p>###最后</p><p>channel和topic的实现类似,并且给了我一种channel和topic可以再抽象一层做代码复用的感觉.</p><p>两者都是内存通道+后端落盘.都是磁盘消息与内存消息竞争执行处理.</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ul><li><a href="https://nsq.io/clients/tcp_protocol_spec.html" target="_blank" rel="noopener">https://nsq.io/clients/tcp_protocol_spec.html</a></li><li><a href="https://github.com/nsqio/nsq" target="_blank" rel="noopener">https://github.com/nsqio/nsq</a></li><li><a href="https://blog.csdn.net/skh2015java/article/details/83419493" target="_blank" rel="noopener">https://blog.csdn.net/skh2015java/article/details/83419493</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;p&gt;此channel非彼channel,只是跟golang的channel同名而已,它是NSQ消费者订阅特定Topic的一种抽象.nsqd抽到生产者push的message后,会遍历当前topic下所有消费者channel并深度拷贝message下发
      
    
    </summary>
    
    
      <category term="中间件" scheme="https://blog.yindex.org/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="golang" scheme="https://blog.yindex.org/tags/golang/"/>
    
      <category term="nsq" scheme="https://blog.yindex.org/tags/nsq/"/>
    
      <category term="消息队列" scheme="https://blog.yindex.org/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="中间件" scheme="https://blog.yindex.org/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="Channel" scheme="https://blog.yindex.org/tags/Channel/"/>
    
  </entry>
  
  <entry>
    <title>NSQ延迟消息投递</title>
    <link href="https://blog.yindex.org/2019/04/14/2019-04-20-NSQ%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E5%88%86%E6%9E%90-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF/"/>
    <id>https://blog.yindex.org/2019/04/14/2019-04-20-NSQ%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E5%88%86%E6%9E%90-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF/</id>
    <published>2019-04-14T00:00:00.000Z</published>
    <updated>2020-02-26T12:31:13.064Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h1 id="Deferred-Message"><a href="#Deferred-Message" class="headerlink" title="Deferred Message"></a>Deferred Message</h1><p>NSQ support deferred message, We can publish a deferred message to a topic by DPUB.NSQ目前在TCP客户端呢支持独立接口延迟消息,http PUB接口作为参数选项支持.并且nsq版本需要大于等于0.3.6.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DPUB &lt;topic_name&gt; &lt;defer_time&gt;\n</span><br><span class="line">[ 4-byte size <span class="keyword">in</span> bytes ][ N-byte binary data ]</span><br><span class="line"></span><br><span class="line">&lt;topic_name&gt; - a valid string (optionally having <span class="comment">#ephemeral suffix)</span></span><br><span class="line">&lt;defer_time&gt; - a string representation of <span class="built_in">integer</span> D <span class="built_in">which</span> defines the time <span class="keyword">for</span> how long to defer <span class="built_in">where</span> 0 &lt;= D &lt; max-requeue-timeout</span><br></pre></td></tr></table></figure><p>Success Response</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OK</span><br></pre></td></tr></table></figure><p>Error Response</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E_INVALID</span><br><span class="line">E_BAD_TOPIC</span><br><span class="line">E_BAD_MESSAGE</span><br><span class="line">E_DPUB_FAILED</span><br></pre></td></tr></table></figure><h1 id="Deferred-Message实现"><a href="#Deferred-Message实现" class="headerlink" title="Deferred Message实现"></a>Deferred Message实现</h1><h2 id="Deferred-Message-produce"><a href="#Deferred-Message-produce" class="headerlink" title="Deferred Message produce"></a>Deferred Message produce</h2><p>Deferred Message 在TCP接口中提供, 那就从消息生产开始阅读. nsqd/protocl_v2.go中TCP路由实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Exec 可以理解为 tcp 的 router</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">Exec</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"IDENTIFY"</span>)) &#123; <span class="comment">// client 注册</span></span><br><span class="line"><span class="keyword">return</span> p.IDENTIFY(client, params)</span><br><span class="line">&#125;</span><br><span class="line">err := enforceTLSPolicy(client, p, params[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"FIN"</span>)): <span class="comment">// 一条消息消费完毕</span></span><br><span class="line"><span class="keyword">return</span> p.FIN(client, params)</span><br><span class="line"><span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"RDY"</span>)): <span class="comment">// consumer 当前能消费多少消息</span></span><br><span class="line"><span class="keyword">return</span> p.RDY(client, params)</span><br><span class="line"><span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"REQ"</span>)): <span class="comment">// 重新发送一条消息</span></span><br><span class="line"><span class="keyword">return</span> p.REQ(client, params)</span><br><span class="line"><span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"PUB"</span>)): <span class="comment">// producer 发布一条消息</span></span><br><span class="line"><span class="keyword">return</span> p.PUB(client, params)</span><br><span class="line"><span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"MPUB"</span>)): <span class="comment">// producer 发布多条消息</span></span><br><span class="line"><span class="keyword">return</span> p.MPUB(client, params)</span><br><span class="line"><span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"DPUB"</span>)): <span class="comment">// producer 延迟发布消息</span></span><br><span class="line"><span class="keyword">return</span> p.DPUB(client, params)</span><br><span class="line"><span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"NOP"</span>)): <span class="comment">// 无操作</span></span><br><span class="line"><span class="keyword">return</span> p.NOP(client, params)</span><br><span class="line"><span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"TOUCH"</span>)): <span class="comment">// 修改消息的 timeout 时间，但是不重新发送</span></span><br><span class="line"><span class="keyword">return</span> p.TOUCH(client, params)</span><br><span class="line"><span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"SUB"</span>)): <span class="comment">// consumer 订阅 channel</span></span><br><span class="line"><span class="keyword">return</span> p.SUB(client, params)</span><br><span class="line"><span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"CLS"</span>)): <span class="comment">// client close</span></span><br><span class="line"><span class="keyword">return</span> p.CLS(client, params)</span><br><span class="line"><span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"AUTH"</span>)): <span class="comment">// client 鉴权</span></span><br><span class="line"><span class="keyword">return</span> p.AUTH(client, params)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, fmt.Sprintf(<span class="string">"invalid command %s"</span>, params[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中bytes.Equal(params[0], []byte(“DPUB”)这个分支为延迟消息投递方式,根据NSQ TCP协议中第一个参数确定路由去向,当你参数为DPUB时生产延迟消息,调用<code>protocolV2.DPUB</code>读取生产者生产的内容. </p><p><strong><code>protocolV2.DPUB</code></strong>主要读取消息内容、TOPIC以及它特有的延迟时间.</p><p>延迟投递时间在协议参数的中第三个参数中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> timeoutDuration := time.Duration(timeoutMs) * time.Millisecond</span><br></pre></td></tr></table></figure><p>从代码中可以看出,deferred message的单位时毫秒. 最后将延迟时间设置到Message类型的deferred字段上,并通过把该消息投递到topic中. 延迟消息与其他消息的实现基本相同,唯一的区别就是延迟消息设置了msg.deferred.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">topic := p.ctx.nsqd.GetTopic(topicName)</span><br><span class="line">msg := NewMessage(topic.GenerateID(), messageBody)</span><br><span class="line">msg.deferred = timeoutDuration</span><br><span class="line">err = topic.PutMessage(msg)</span><br></pre></td></tr></table></figure><h2 id="Deferred-Message-Consume"><a href="#Deferred-Message-Consume" class="headerlink" title="Deferred Message Consume"></a>Deferred Message Consume</h2><p>直接查看topic.go文件,消息投递从该文件Topic.messagePump开始, 在该方法中把后端消息内容平行复制到N个消费通道中.消息复制关键代码如下<code>topic.go/Topic.messagePump</code>方法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, channel := <span class="keyword">range</span> chans &#123;</span><br><span class="line">chanMsg := msg</span><br><span class="line"><span class="comment">// copy the message because each channel</span></span><br><span class="line"><span class="comment">// needs a unique instance but...</span></span><br><span class="line"><span class="comment">// fastpath to avoid copy if its the first channel</span></span><br><span class="line"><span class="comment">// (the topic already created the first copy)</span></span><br><span class="line"><span class="comment">// 这里 msg 实例要进行深拷贝，因为每个 channel 需要自己的实例</span></span><br><span class="line"><span class="comment">// 为了重发/延迟发送等</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">chanMsg = NewMessage(msg.ID, msg.Body)</span><br><span class="line">chanMsg.Timestamp = msg.Timestamp</span><br><span class="line">chanMsg.deferred = msg.deferred</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> chanMsg.deferred != <span class="number">0</span> &#123;</span><br><span class="line">channel.PutMessageDeferred(chanMsg, chanMsg.deferred)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">err := channel.PutMessage(chanMsg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.ctx.nsqd.logf(LOG_ERROR,</span><br><span class="line"><span class="string">"TOPIC(%s) ERROR: failed to put msg(%s) to channel(%s) - %s"</span>,</span><br><span class="line">t.name, msg.ID, channel.name, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看到当投递过来的消息(Message)的deferred字段不为0时, 则通过通道的PutMessageDeferred方法将消息放回延迟队列中.否则将消息投递至消费通道队列.</p><p>查看<code>PutMessageDeferred</code>方法实现方式继续跟踪延迟消息去向:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">PutMessageDeferred</span><span class="params">(msg *Message, timeout time.Duration)</span></span> &#123;</span><br><span class="line">atomic.AddUint64(&amp;c.messageCount, <span class="number">1</span>)</span><br><span class="line">c.StartDeferredTimeout(msg, timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StartDeferredTimeout实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// StartDeferredTimeout 将一条消息写入 Deferred 队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">StartDeferredTimeout</span><span class="params">(msg *Message, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">absTs := time.Now().Add(timeout).UnixNano() <span class="comment">// 生成延迟发送的时间</span></span><br><span class="line">item := &amp;pqueue.Item&#123;Value: msg, Priority: absTs&#125;</span><br><span class="line">err := c.pushDeferredMessage(item)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">c.addToDeferredPQ(item)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StartDeferredTimeout方法执行了两个操作:<code>pushDeferredMessage</code>, <code>addToDeferredPQ</code></p><ul><li>pushDeferredMessage方法将消息写入到延迟消息通道的Map类型字段上(可以去重复~)</li><li>addToDeferredPQ方法将消息写入 DeferredPQ 这个优先级队列</li></ul><p>我们查看channel.go发现, func (c *Channel) processDeferredQueue(t int64) bool函数, 发现在此处对存储延迟消息的优先队列进行了弹出操作.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">processDeferredQueue</span><span class="params">(t <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">c.exitMutex.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.exitMutex.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.Exiting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dirty := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c.deferredMutex.Lock()</span><br><span class="line">item, _ := c.deferredPQ.PeekAndShift(t)</span><br><span class="line">c.deferredMutex.Unlock()</span><br><span class="line"><span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line">&#125;</span><br><span class="line">dirty = <span class="literal">true</span></span><br><span class="line">msg := item.Value.(*Message)</span><br><span class="line">_, err := c.popDeferredMessage(msg.ID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line">&#125;</span><br><span class="line">c.put(msg)</span><br><span class="line">&#125;</span><br><span class="line">exit:</span><br><span class="line"><span class="keyword">return</span> dirty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中这一句<code>item, _ := c.deferredPQ.PeekAndShift(t)</code>进行了时间判断,看一下实现方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">PeekAndShift</span><span class="params">(max <span class="keyword">int64</span>)</span> <span class="params">(*Item, <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pq.Len() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">item := (*pq)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> item.Priority &gt; max &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, item.Priority - max</span><br><span class="line">&#125;</span><br><span class="line">heap.Remove(pq, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> item, <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PeekAndShift</code>方法中根据消息的到期时间与传入的max做了比较,如果消息到期时间大于传入的max,则返回该item,否则返回nil, 根据调用链可以知道<code>max</code>值为当前时间.</p><p>再回到调<code>PeekAndShift</code>的<code>processDeferredQueue</code>方法中看到,如果PeekAndShift成功了,则进行pop操作,并将该消息put到非延迟队列.(<strong>反射时deferred参数未设置,则默认为0,所以投递后不会在回到延迟队列</strong>).</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ul><li><a href="https://nsq.io/clients/tcp_protocol_spec.html" target="_blank" rel="noopener">https://nsq.io/clients/tcp_protocol_spec.html</a></li><li><a href="https://github.com/nsqio/nsq" target="_blank" rel="noopener">https://github.com/nsqio/nsq</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;h1 id=&quot;Deferred-Message&quot;&gt;&lt;a href=&quot;#Deferred-Message&quot; class=&quot;headerlink&quot; title=&quot;Deferred Message&quot;&gt;&lt;/a&gt;Deferred Message&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="中间件" scheme="https://blog.yindex.org/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="golang" scheme="https://blog.yindex.org/tags/golang/"/>
    
      <category term="nsq" scheme="https://blog.yindex.org/tags/nsq/"/>
    
      <category term="消息队列" scheme="https://blog.yindex.org/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="中间件" scheme="https://blog.yindex.org/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="延迟投递" scheme="https://blog.yindex.org/tags/%E5%BB%B6%E8%BF%9F%E6%8A%95%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop Streaming手册[译]</title>
    <link href="https://blog.yindex.org/2019/04/01/2019-04-01-Hadoop%20Streaming[%E8%AF%91]/"/>
    <id>https://blog.yindex.org/2019/04/01/2019-04-01-Hadoop%20Streaming[%E8%AF%91]/</id>
    <published>2019-04-01T00:00:00.000Z</published>
    <updated>2020-02-26T12:31:13.064Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>hadoop streaming是hadoop发行版附带的功能. 该功能让我们可以使用任何程序或脚本作为mapper和reducer 来创建Map/Reduce作业.例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-streaming-2.9.2.jar \</span><br><span class="line">-input inputDirs \</span><br><span class="line">-output outputDirs \</span><br><span class="line">-mapper /bin/cat \</span><br><span class="line">-reducer /usr/bin/wc</span><br></pre></td></tr></table></figure><h2 id="Streaming运行原理"><a href="#Streaming运行原理" class="headerlink" title="Streaming运行原理"></a>Streaming运行原理</h2><p>上述例子中，mapper和reducer都是执行程序，该执行程序从标准输入(stdin)逐行读取数据并将数据吐到标准输出(stdout)中.hadoop streaming创建Map/Reduce作业、提交到对应的集群中并监控作业运行进度.</p><p>指定一个可执行程序作为mapper并初始化成功后，每个mapper任务将启动该执行程序.　当mapper作业运行时，它讲输入数据转化成行并逐行写入到该执行程序进程的标准输入中.同时mapper作业面向行收集该执行程序进程的标准输出(以\n作为分割符切分数据)并将每行数据转成成key/value格式，将转化后的kv数据作为mapper作业的输出. 默认配置下，以tab作为分割符，每行数据分割后第一部分作为key其余部分作为value.如果行数据中没有制表符那么整行数据作为key, value为空. 我们可以通过设置-inputformat命令行参数来个性化定制key value格式．</p><p>这是Map/Reduce框架与streaming mapper/reduce通信协议的基础.</p><p>用户可以通过设置 <code>stream.non.zero.exit.is.failure</code>参数（true|false）来确定streaming作业是以非零状态退出表示作业运行成功或失败．默认情况下,streaming　作业进程以非零状态退出表示任务失败.</p><h2 id="Streaming-命令行选项"><a href="#Streaming-命令行选项" class="headerlink" title="Streaming 命令行选项"></a>Streaming 命令行选项</h2><p>Streaming 支持hadoop通用命令行选项的同时也支持streaming命令行选项，下面展示了常规命令行选项的语法格式.</p><p><strong>注意：</strong>　一定要把通用命令行选项设置放置在streaming命令行选项之前，否则命令行选项设置将无效. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop <span class="built_in">command</span> [genericOptions] [streamingOptions]</span><br></pre></td></tr></table></figure><p><strong>Ｈadoop streaming 命令行选项列表如下.</strong></p><table><thead><tr><th align="left">参数</th><th align="center">必选</th><th>描述</th></tr></thead><tbody><tr><td align="left">-input 目录名或文件名</td><td align="center">是</td><td>mapper作业输入数据位置</td></tr><tr><td align="left">-output 目录名</td><td align="center">是</td><td>reducer作业输出位置</td></tr><tr><td align="left">-mapper 执行程序或Java类名</td><td align="center">否</td><td>Mapper执行程序，若未设置则默认使用IdentityMapper</td></tr><tr><td align="left">-reducer 执行程序或Java类名</td><td align="center">否</td><td>Reducer执行程序，若未设置则默认使用IdentityReducer</td></tr><tr><td align="left">-file 文件名</td><td align="center">否</td><td>让mapper,reducer,combiner作业能够在对应节点上本地化读取该文件</td></tr><tr><td align="left">-inputformat JavaClassName</td><td align="center">否</td><td>设置的类必须返回 key(Text类型)/Values(Text类型)键值对．若未设置该选项则默认使用TextInputFormat</td></tr><tr><td align="left">-outputformat JavaClassName</td><td align="center">否</td><td>同上</td></tr><tr><td align="left">-partioner JavaClassName</td><td align="center">否</td><td>该类确定输出数据数据写入到哪一个reduce分区</td></tr><tr><td align="left">-combiner streaming命令或JavaClassName</td><td align="center">否</td><td></td></tr><tr><td align="left">-cmdenv name=value</td><td align="center">否</td><td>给streaming作业传递环境变量</td></tr><tr><td align="left">-inputreader</td><td align="center">否</td><td></td></tr><tr><td align="left">-verbose</td><td align="center">否</td><td>verbose输出</td></tr><tr><td align="left">-lazyOutput</td><td align="center">否</td><td></td></tr><tr><td align="left">-numReduceTasks</td><td align="center">否</td><td>reducer作业数量(mapreduce.job.reduces)</td></tr><tr><td align="left">-mapdebug</td><td align="center">否</td><td>map作业失败时调用的脚本</td></tr><tr><td align="left">-reducedebug</td><td align="center">否</td><td>reduce作业失败时调用的脚本</td></tr></tbody></table><p>###指定Java类作为Mapper/Reducer</p><p>我们可以提供一个Java类作为mapper或者reducer</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-streaming-2.9.2.jar \</span><br><span class="line">-input inputdirs \</span><br><span class="line">-output outputdir \</span><br><span class="line">-inputformat org.apache.hadoop.mapred.KeyValueTextInputFormat \</span><br><span class="line">-mapper org.apache.hadoop.mapred.lib.IdentifyMapper \</span><br><span class="line">-reducer /usr/bin/wc</span><br></pre></td></tr></table></figure><p>我们可以通过设置<code>stream.non.zero.exit.is.failure</code>为<code>false</code>或<code>true</code>来确定是否以执行程序退出非零状态码来表示任务成功或失败. 默认程序非零退出状态表示任务失败.</p><p>###文件打包到作业提交</p><p>我们可以执行任意执行程序作为mapper或reducer.可执行程序并不需要预先保存在集群上;若未提前保存在集群节点中,则需要通过<code>-file</code>选项通知框架打包相应执行程序作为作业提交的一部分. 例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-streaming-2.9.2.jar \</span><br><span class="line">-input inputdirs \</span><br><span class="line">-output outputdir \</span><br><span class="line">-mapper mapper.py \</span><br><span class="line">-reducer /usr/bin/wc \</span><br><span class="line">-file mapper.py</span><br></pre></td></tr></table></figure><p>上如例子中指定了一个用户定义的python 可执行脚本作为mapper. <code>-file mapper.py</code> 将python可执行文件作为作业提交的一部分传输到集群.除了打包可执行文件,还可以打包其他辅助文件(比如字典文件,配置文件等)供mapper作业使用. 如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-streaming-2.9.2.jar \</span><br><span class="line">  -input myInputDirs \</span><br><span class="line">  -output myOutputDir \</span><br><span class="line">  -mapper myPythonScript.py \</span><br><span class="line">  -reducer /usr/bin/wc \</span><br><span class="line">  -file myPythonScript.py \</span><br><span class="line">  -file myDictionary.txt</span><br></pre></td></tr></table></figure><p>###为作业指定其他插件</p><p>跟其他普通Map/Reduce作业一样,我们可以指定其他插件到streaming作业.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-inputformat JavaClassName</span><br><span class="line">-outputformat JavaClassName</span><br><span class="line">-partitioner JavaClassName</span><br><span class="line">-combiner streamingCommand or JavaClassName</span><br></pre></td></tr></table></figure><p>给输入格式指定的Java类必须返回Text 格式的键值对类型. 若没有特别指定输入格式处理类,那么<code>TextInputFormat</code>将作为默认处理类.由于<code>TextInputFormat</code> 返回LongWriteable类型key, 并且key不是输入数据的一部分,key会被丢弃.只有值会通过管道传递给streaming mapper.</p><p>为输出格式指定的类应该采用<code>Text</code>类型对键值对类型.如果没有指定输出格式处理类,<code>TextOutputFormat</code>作为默认处理类.</p><p>###设置环境变量</p><p>通过下述方式再streaming命令行中设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-cmdenv EXAMPLE_DIR=/home/example/dic/</span><br></pre></td></tr></table></figure><h2 id="通用命令行选项"><a href="#通用命令行选项" class="headerlink" title="通用命令行选项"></a>通用命令行选项</h2><p>Hadoop streaming支持streaming命令行选项也支持hadoop通用命令行选项.通用命令行选项设置方式如下</p><p><strong>注意:</strong>  一定要把通用命令行选项设置放置在streaming命令行选项之前，否则命令行选项设置将无效. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop <span class="built_in">command</span> [genericOptions] [streamingOptions]</span><br></pre></td></tr></table></figure><p>Streaming可以使用的hadoop命令行选项如下表所示:</p><table><thead><tr><th>参数</th><th align="center">必须</th><th>描述</th></tr></thead><tbody><tr><td>-conf configfile</td><td align="center">否</td><td>指定特定的配置文件</td></tr><tr><td>-D</td><td align="center">否</td><td>设置指定的属性(Dkey=value)</td></tr><tr><td>-fs host:port or local</td><td align="center">否</td><td>指定namenode</td></tr><tr><td>-files</td><td align="center">否</td><td>指定需要copy到集群的文件,多个文件用逗号分开</td></tr><tr><td>-libjars</td><td align="center">否</td><td>指定需要copy到集群classpath的jar文件,多个文件用逗号分开</td></tr><tr><td>-archives</td><td align="center">否</td><td>指定要上传到集群并解压到压缩文件,多个文件用逗号分开</td></tr></tbody></table><p>###使用-D选项设置配置变量</p><p>我们可以使用`-D<property>=<value>来设置额外的配置.</p><h4 id="设置目录"><a href="#设置目录" class="headerlink" title="设置目录"></a>设置目录</h4><p>修改节点本地临时目录路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D dfs.data.dir=/tmp</span><br></pre></td></tr></table></figure><p>设置额外的本地临时目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-D mapred.local.dir=/tmp/<span class="built_in">local</span></span><br><span class="line">-D mapred.system.dir=/tmp/system</span><br><span class="line">-D mapred.temp.dir=/tmp/temp</span><br></pre></td></tr></table></figure><p><strong>注释:</strong> 作业配置参数跟多细节请参考<code>mapred-default.xml</code></p><p>####设置仅运行Map任务作业</p><p>我们经常需要仅运行map函数来处理输入数据,仅仅需要把<code>mapreduce.job.reduces</code>设置为0即可达到此目的.设置为0后,Map/Reduce框架不再创建reduce任务,并且mapper任务等输出会作为作业的最终输出.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D mapreduce.job.reduces=0</span><br></pre></td></tr></table></figure><p>####设置指定数量的Reducers</p><p>设置指定数量的reducers,例如设置2个:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoo-streaming-2.9.2.jar \</span><br><span class="line">-D mapreduce.job.reduces=2\</span><br><span class="line">-input inputdir \</span><br><span class="line">-output outputdir \</span><br><span class="line">-mapper /bin/cat \</span><br><span class="line">-reducer /usr/bin/wc</span><br></pre></td></tr></table></figure><h4 id="自定义输入行分割键值对的方式"><a href="#自定义输入行分割键值对的方式" class="headerlink" title="自定义输入行分割键值对的方式"></a>自定义输入行分割键值对的方式</h4><p>如前面讲到,Map/Reduce框架从mapper任务的标准输出读取行数据时,它会把行数据分割成呢键值对形式.默认配置下,到第一个制表符的数据作为键,其余的数据作为值(不包含制表符tab).</p><p>但是,我们可以修改默认配置.我们可以指定一个分割符号来替换制表符.并且也可以值指定分割后的哪一部分作为key.如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-streaming-2.9.2.jar \</span><br><span class="line">  -D stream.map.output.field.separator=. \</span><br><span class="line">  -D stream.num.map.output.key.fields=4 \</span><br><span class="line">  -input myInputDirs \</span><br><span class="line">  -output myOutputDir \</span><br><span class="line">  -mapper /bin/cat \</span><br><span class="line">  -reducer /bin/cat</span><br></pre></td></tr></table></figure><p>上面的例子中,通过<code>-D stream.map.output.field.separator=.</code>设置<code>.</code>作为map输出的字段分割符.并且指定到第四个分割符的前缀部分作为key,其余部分作为值.如果一行数据中的风格符号<code>.</code>不够4个那么整行数据讲作为key,值部分为空.</p><p>类似的,我们可以使用<code>-D stream.reduce.output.field.separator=SEP</code>和 <code>-D stream.num.reduce.output.fields=NUM</code> 来确定reduce的输出数据中哪一部分作为key哪一部分作为value.</p><p>类似上述方式,可以通过<code>stream.map.input.field.separato</code> 和<code>stream.reduce.input.field.separator</code>来设置Map/Reduce作业的输入数据分割符号.默认设置是以制表符作为字段分割符号.</p><h3 id="使用大文件和归档文件"><a href="#使用大文件和归档文件" class="headerlink" title="使用大文件和归档文件"></a>使用大文件和归档文件</h3><p><code>-files</code>和<code>-archives</code>选项让我们可以在任务中使用普通文件和归档文件.它们的参数是指向上传到hdfs的文件或归档文件到URI.这些文件缓存在作业中.我们可以通过fs.default.name配置变量获取host和fs_port.</p><p><strong>注意:</strong> -files和-archives选项是hadoop通用命令行选项,一定要把它们放置在hadoop streaming选项之前,否则设置无效. </p><h4 id="让任务可访问文件"><a href="#让任务可访问文件" class="headerlink" title="让任务可访问文件"></a>让任务可访问文件</h4><p>-files选项在当前任务的工作目录创建指向本地文件副本的符号连接.下面例子中hadoop在当前工作目录中自动创建了名为testfile.txt的符号链接.链接指向了本地testfile.txt副本.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-files hdfs://host:fs_port/usr/testfile.txt</span><br></pre></td></tr></table></figure><p>也可以使用<code>#</code>来为-files 指定的文件创建一个不同名称的符号链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-files hdfs://host:fs_port/user/testfile.txt<span class="comment">#cachefile.txt</span></span><br></pre></td></tr></table></figure><p>如果有多个文件可以用逗号分开,如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-files /home/usr/testfile1.txt, /home/user/estfile2.txt</span><br></pre></td></tr></table></figure><h4 id="任务访问归档文件"><a href="#任务访问归档文件" class="headerlink" title="任务访问归档文件"></a>任务访问归档文件</h4><p>-archives选项让我们可以把本地jars文件复制到当前任务的工作目录并unjar(解压).</p><p>下面例子中,hadoop在任务当前工作目录中创建了一个名为testfile.jar的符号链接.这个符号链接指向了上传的jar文件解压后的目录.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-archives hdfs://host:fs_port/user/testfile.jar</span><br></pre></td></tr></table></figure><p>使用<code>#</code>符号为-archives上传文件、解压后的目录创建一个不同名字的符号链接.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-archives hdfs://host:fs_port/user/testfile.tgz<span class="comment">#tgzdir</span></span><br></pre></td></tr></table></figure><p>下面例子中,input.txt包含两行数据,分别表示两个文件: cachedir.jar/cache.txt 和 cacheddir.jar/cache2.txt.  cacheddir.jar是指向包含cache.txt和cache2.txt文件的归档目录的一个符号链接.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-streaming-2.9.2.jar \</span><br><span class="line">                -archives <span class="string">'hdfs://hadoop-nn1.example.com/user/me/samples/cachefile/cachedir.jar'</span> \</span><br><span class="line">                -D mapreduce.job.maps=1 \</span><br><span class="line">                -D mapreduce.job.reduces=1 \</span><br><span class="line">                -D mapreduce.job.name=<span class="string">"Experiment"</span> \</span><br><span class="line">                -input <span class="string">"/user/me/samples/cachefile/input.txt"</span> \</span><br><span class="line">                -output <span class="string">"/user/me/samples/cachefile/out"</span> \</span><br><span class="line">                -mapper <span class="string">"xargs cat"</span> \</span><br><span class="line">                -reducer <span class="string">"cat"</span></span><br><span class="line"></span><br><span class="line">$ ls test_jar/</span><br><span class="line">cache.txt  cache2.txt</span><br><span class="line"></span><br><span class="line">$ jar cvf cachedir.jar -C test_jar/ .</span><br><span class="line">added manifest</span><br><span class="line">adding: cache.txt(<span class="keyword">in</span> = 30) (out= 29)(deflated 3%)</span><br><span class="line">adding: cache2.txt(<span class="keyword">in</span> = 37) (out= 35)(deflated 5%)</span><br><span class="line"></span><br><span class="line">$ hdfs dfs -put cachedir.jar samples/cachefile</span><br><span class="line"></span><br><span class="line">$ hdfs dfs -cat /user/me/samples/cachefile/input.txt</span><br><span class="line">cachedir.jar/cache.txt</span><br><span class="line">cachedir.jar/cache2.txt</span><br><span class="line"></span><br><span class="line">$ cat test_jar/cache.txt</span><br><span class="line">This is just the cache string</span><br><span class="line"></span><br><span class="line">$ cat test_jar/cache2.txt</span><br><span class="line">This is just the second cache string</span><br><span class="line"></span><br><span class="line">$ hdfs dfs -ls /user/me/samples/cachefile/out</span><br><span class="line">Found 2 items</span><br><span class="line">-rw-r--r-* 1 me supergroup        0 2013-11-14 17:00 /user/me/samples/cachefile/out/_SUCCESS</span><br><span class="line">-rw-r--r-* 1 me supergroup       69 2013-11-14 17:00 /user/me/samples/cachefile/out/part-00000</span><br><span class="line"></span><br><span class="line">$ hdfs dfs -cat /user/me/samples/cachefile/out/part-00000</span><br><span class="line">This is just the cache string</span><br><span class="line">This is just the second cache string</span><br></pre></td></tr></table></figure><h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><h3 id="Hadoop分区类"><a href="#Hadoop分区类" class="headerlink" title="Hadoop分区类"></a>Hadoop分区类</h3><p>Hadoop有个对很多应用程序非常有用的类<code>KeyFieldBasePartitioner</code>.通过该类我们可以使Map/Reduce框架通过key中的一些字段来对输出进行分区,而不需要使用整个key域.例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-streaming-2.9.2.jar \</span><br><span class="line">  -D stream.map.output.field.separator=. \</span><br><span class="line">  -D stream.num.map.output.key.fields=4 \</span><br><span class="line">  -D map.output.key.field.separator=. \</span><br><span class="line">  -D mapreduce.partition.keypartitioner.options=-k1,2 \</span><br><span class="line">  -D mapreduce.job.reduces=12 \</span><br><span class="line">  -input myInputDirs \</span><br><span class="line">  -output myOutputDir \</span><br><span class="line">  -mapper /bin/cat \</span><br><span class="line">  -reducer /bin/cat \</span><br><span class="line">  -partitioner org.apache.hadoop.mapred.lib.KeyFieldBasedPartitioner</span><br></pre></td></tr></table></figure><p>上面例子里,<em>-D stream.map.output.field.separator=.</em> 和 <em>-D stream.num.map.output.key.fields=4</em> 用法含义已经在前面解释过.整个两个变量主要用来确定streaming中的key和value.</p><p>Map/Reduce作业中map阶段的输出包含四个字段并用<code>.</code>隔开. Map/Reduce框架通过 <code>-Dmapred.text.key.partitioner.option=k1,2</code> 选项确定使用key中前两个字段将map输出分区. <code>-Dmap.output.key.field.separator=.</code>指定输出数据字段间的分割符号.从而保证了key中前两个字段相同的数据将分配给同一个reducer任务(写入到容一个分区中).</p><p>这相当于将key分成4个字段,前两个字段为联合主键其余部分为次主键. 主键部分用于分区(确定写到哪个分区上),主键与次主键组合用于字典排序.通过下面例子可以诠释一下:</p><p>map输出数据的key部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11.12.1.2</span><br><span class="line">11.14.2.3</span><br><span class="line">11.11.4.1</span><br><span class="line">11.12.1.1</span><br><span class="line">11.14.2.2</span><br></pre></td></tr></table></figure><p>写入到三个分区中(前两个字段用于分区键)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">11.11.4.1</span><br><span class="line">-----------</span><br><span class="line">11.12.1.2</span><br><span class="line">11.12.1.1</span><br><span class="line">-----------</span><br><span class="line">11.14.2.3</span><br><span class="line">11.14.2.2</span><br></pre></td></tr></table></figure><p>每个分区中使用整个全部字段进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">11.11.4.1</span><br><span class="line">-----------</span><br><span class="line">11.12.1.1</span><br><span class="line">11.12.1.2</span><br><span class="line">-----------</span><br><span class="line">11.14.2.2</span><br><span class="line">11.14.2.3</span><br></pre></td></tr></table></figure><h3 id="Hadoop-Comparator-Class"><a href="#Hadoop-Comparator-Class" class="headerlink" title="Hadoop Comparator Class"></a>Hadoop Comparator Class</h3><p>Hadoop类库中,KeyFieldBasedComparator也是一个非常有用的类库.它实现了Unix/GNU sort特定的一个子集.例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-streaming-2.9.2.jar \</span><br><span class="line">  -D mapreduce.job.output.key.comparator.class=org.apache.hadoop.mapreduce.lib.partition.KeyFieldBasedComparator \</span><br><span class="line">  -D stream.map.output.field.separator=. \</span><br><span class="line">  -D stream.num.map.output.key.fields=4 \</span><br><span class="line">  -D mapreduce.map.output.key.field.separator=. \</span><br><span class="line">  -D mapreduce.partition.keycomparator.options=-k2,2nr \</span><br><span class="line">  -D mapreduce.job.reduces=1 \</span><br><span class="line">  -input myInputDirs \</span><br><span class="line">  -output myOutputDir \</span><br><span class="line">  -mapper /bin/cat \</span><br><span class="line">  -reducer /bin/cat</span><br></pre></td></tr></table></figure><p>如前面讲使用<code>.</code>分割字段等等. <code>-k2,2nr</code>表示以key中第二个字段作为排序字段, -n表示数字排序, -r表示逆序.如下所示,map的输出内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11.12.1.2</span><br><span class="line">11.14.2.3</span><br><span class="line">11.11.4.1</span><br><span class="line">11.12.1.1</span><br><span class="line">11.14.2.2</span><br></pre></td></tr></table></figure><p>排序后的内容为(使用第二个字段排序,并且是将序[14,14,12,12,11])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11.14.2.3</span><br><span class="line">11.14.2.2</span><br><span class="line">11.12.1.2</span><br><span class="line">11.12.1.1</span><br><span class="line">11.11.4.1</span><br></pre></td></tr></table></figure><h3 id="Hadoop-Aggregate-Package"><a href="#Hadoop-Aggregate-Package" class="headerlink" title="Hadoop Aggregate Package"></a>Hadoop Aggregate Package</h3><pre><code>Hadoop有一个类库Aggregate. Aggregate提供一些特定reducer类,combiner类,以及一些简单的聚合操操作,如&quot;sum&quot;,&quot;max&quot;,&quot;min&quot;等等. 使用Aggregate我们可以定义一些mapper插件类用于生成相应的聚合选项.</code></pre><p>一个聚合例子(-reducer aggregate)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-streaming-2.9.2.jar \</span><br><span class="line">  -input myInputDirs \</span><br><span class="line">  -output myOutputDir \</span><br><span class="line">  -mapper myAggregatorForKeyCount.py \</span><br><span class="line">  -reducer aggregate \</span><br><span class="line">  -file myAggregatorForKeyCount.py \</span><br></pre></td></tr></table></figure><p>myAggregatorForKeyCount.py代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateLongCountToken</span><span class="params">(id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"LongValueSum:"</span> + id + <span class="string">"\t"</span> + <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">    line = sys.stdin.readline();</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> line:</span><br><span class="line">            line = line&amp;<span class="comment">#91;:-1];</span></span><br><span class="line">            fields = line.split(<span class="string">"\t"</span>);</span><br><span class="line">            <span class="keyword">print</span> generateLongCountToken(fields&amp;<span class="comment">#91;0]);</span></span><br><span class="line">            line = sys.stdin.readline();</span><br><span class="line">    <span class="keyword">except</span> <span class="string">"end of file"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">     main(sys.argv)</span><br></pre></td></tr></table></figure><h3 id="Hadoop-Field-Selection-Class"><a href="#Hadoop-Field-Selection-Class" class="headerlink" title="Hadoop Field Selection Class"></a>Hadoop Field Selection Class</h3><p>Hadoop has a library class, FieldSelectionMapReduce, that effectively allows you to process text data like the unix “cut” utility. The map function defined in the class treats each input key/value pair as a list of fields. You can specify the field separator (the default is the tab character). You can select an arbitrary list of fields as the map output key, and an arbitrary list of fields as the map output value. Similarly, the reduce function defined in the class treats each input key/value pair as a list of fields. You can select an arbitrary list of fields as the reduce output key, and an arbitrary list of fields as the reduce output value. For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-streaming-2.9.2.jar \</span><br><span class="line">  -D mapreduce.map.output.key.field.separator&#x3D;. \</span><br><span class="line">  -D mapreduce.partition.keypartitioner.options&#x3D;-k1,2 \</span><br><span class="line">  -D mapreduce.fieldsel.data.field.separator&#x3D;. \</span><br><span class="line">  -D mapreduce.fieldsel.map.output.key.value.fields.spec&#x3D;6,5,1-3:0- \</span><br><span class="line">  -D mapreduce.fieldsel.reduce.output.key.value.fields.spec&#x3D;0-2:5- \</span><br><span class="line">  -D mapreduce.map.output.key.class&#x3D;org.apache.hadoop.io.Text \</span><br><span class="line">  -D mapreduce.job.reduces&#x3D;12 \</span><br><span class="line">  -input myInputDirs \</span><br><span class="line">  -output myOutputDir \</span><br><span class="line">  -mapper org.apache.hadoop.mapred.lib.FieldSelectionMapReduce \</span><br><span class="line">  -reducer org.apache.hadoop.mapred.lib.FieldSelectionMapReduce \</span><br><span class="line">  -partitioner org.apache.hadoop.mapred.lib.KeyFieldBasedPartitioner</span><br></pre></td></tr></table></figure><p>The option “-D mapreduce.fieldsel.map.output.key.value.fields.spec=6,5,1-3:0-” specifies key/value selection for the map outputs. Key selection spec and value selection spec are separated by “:”. In this case, the map output key will consist of fields 6, 5, 1, 2, and 3. The map output value will consist of all fields (0- means field 0 and all the subsequent fields).</p><p>The option “-D mapreduce.fieldsel.reduce.output.key.value.fields.spec=0-2:5-” specifies key/value selection for the reduce outputs. In this case, the reduce output key will consist of fields 0, 1, 2 (corresponding to the original fields 6, 5, 1). The reduce output value will consist of all fields starting from field 5 (corresponding to all the original fields).</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li>How do I use Hadoop Streaming to run an arbitrary set of (semi) independent tasks?</li><li>How do I process files, one per map?</li><li>应该使用多少个reducer</li><li>在脚本里设置的别名,-mapper结束后还能用么?</li><li>能使用unix 管道么?<br>…</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;hadoop streaming是hadoop发行版附带的功能. 该功能让我们可以使用任何程序或脚本作为mapp
      
    
    </summary>
    
    
      <category term="hadoop" scheme="https://blog.yindex.org/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="https://blog.yindex.org/tags/hadoop/"/>
    
      <category term="streaming" scheme="https://blog.yindex.org/tags/streaming/"/>
    
  </entry>
  
  <entry>
    <title>NSQ源码阅读-nsqlookupd组件</title>
    <link href="https://blog.yindex.org/2019/03/10/2019-03-10-NSQ%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-nsqlookupd%E7%BB%84%E4%BB%B6/"/>
    <id>https://blog.yindex.org/2019/03/10/2019-03-10-NSQ%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-nsqlookupd%E7%BB%84%E4%BB%B6/</id>
    <published>2019-03-10T00:00:00.000Z</published>
    <updated>2020-02-26T12:31:13.060Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><blockquote><p>NSQ包含三大组件nsqd、nsqlookup、nsqadmin. nsqlookupd 是守护进程负责管理拓扑信息,客户端通过查询 nsqlookupd 来发现指定topic的生产者，并且 nsqd 节点广播topic和channel信息.它包含两个接口：TCP 接口:处理nsqd广播。HTTP 接口:客户端用它来发现和管理服务。</p></blockquote><h2 id="一、NSQLookupd类型"><a href="#一、NSQLookupd类型" class="headerlink" title="一、NSQLookupd类型"></a>一、NSQLookupd类型</h2><p>nsqlookupd.go为nsqlookup组件的入口文件,它主要包含一个NSQLookupd结构类型和该类型的工厂方法func New(*Options)*NSQLookupd.</p><p>NSQLookupd类型属性定义如下.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NSQLookupd <span class="keyword">struct</span> &#123;</span><br><span class="line">sync.RWMutex                      </span><br><span class="line">opts         *Options             </span><br><span class="line">tcpListener  net.Listener          </span><br><span class="line">httpListener net.Listener          </span><br><span class="line">waitGroup    util.WaitGroupWrapper </span><br><span class="line">DB           *RegistrationDB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sync.RWMutex 读写锁，主要用来更新DB中的Registration，Topic, Channels.</li><li>opts NSQLookup相关配置.</li><li>tcpListener 用于nsqd与nsqlookupd通信，默认监听4160端口.</li><li>httpListener 用于nsqlookupd与nsqadmin通信默认监听4161端口.</li><li>waitGroup 装饰器模式，wrap了一层sync.WaitGroup，用于系统退出时同步tcpListener、httpListener结束.</li><li>DB 存储当前注册的Registration， Topic， Chanel，用于nsqd的数据管理.</li></ul><p>NSQLookupd类型绑定的方法列表如下.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="function"><span class="keyword">func</span> <span class="params">(n *NSQLookupd)</span> <span class="title">logf</span><span class="params">(level lg.LogLevel, f <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Main</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">RealTCPAddr</span><span class="params">()</span> *<span class="title">net</span>.<span class="title">TCPAddr</span></span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">RealHTTPAddr</span><span class="params">()</span> *<span class="title">net</span>.<span class="title">TCPAddr</span></span></span><br><span class="line">- <span class="function"><span class="keyword">func</span> <span class="title">Exit</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/zixks/nsq-analysis/blob/master/nsqlookupd/logger.go" target="_blank" rel="noopener">logf</a>方法 内部调用了internal日志方法,用于NSQLookupd上下文写日志.</li><li>Main方法主要负责启动、停止,维护tcp http server等操作.</li><li>RealTCPAddr, RealHTTPAddr获取当前服务地址.</li><li>Exit() 同步关闭tcp http服务.</li></ul><h2 id="二、opts-成员"><a href="#二、opts-成员" class="headerlink" title="二、opts  成员"></a>二、opts  成员</h2><p>opts变量主要存储NSQLookup相关配置信息，类型定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line">LogLevel  <span class="keyword">string</span> <span class="string">`flag:"log-level"`</span></span><br><span class="line">LogPrefix <span class="keyword">string</span> <span class="string">`flag:"log-prefix"`</span></span><br><span class="line">Verbose   <span class="keyword">bool</span>   <span class="string">`flag:"verbose"`</span></span><br><span class="line">Logger    Logger</span><br><span class="line">logLevel  lg.LogLevel</span><br><span class="line">TCPAddress       <span class="keyword">string</span> <span class="string">`flag:"tcp-address"`</span></span><br><span class="line">HTTPAddress      <span class="keyword">string</span> <span class="string">`flag:"http-address"`</span></span><br><span class="line">BroadcastAddress <span class="keyword">string</span> <span class="string">`flag:"broadcast-address"`</span></span><br><span class="line">InactiveProducerTimeout time.Duration <span class="string">`flag:"inactive-producer-timeout"`</span> </span><br><span class="line">TombstoneLifetime       time.Duration <span class="string">`flag:"tombstone-lifetime"`</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LogLevel, LogPrefix定义了日志级别、日志前缀，Logger定义具体的日志类型，TCPAddress，HTTPAddress配置http，tcp相关服务监听地址.BroadcastAddress定义了广播地址.</li><li>InactiveProducerTimeout 定义producer失活时间阈值，当超过InactiveProducerTimeout没有收到producer心跳时，则认为当前producer不在活跃.</li><li><a href="https://github.com/mickey0524/nsq-analysis/blob/master/nsqlookupd/options.go#L23" target="_blank" rel="noopener">TombstoneLifetime</a>避免发生竞争，当一个nsqd不再产生一个特定的toipc, 需要去掉这个toipc，这个时候，试图尝试删除topic信息与新的消费者已经发现这个主题的节点，重连, 会更新nsqlookup产生竞争.</li></ul><h2 id="三、waitGroup-成员"><a href="#三、waitGroup-成员" class="headerlink" title="三、waitGroup 成员"></a>三、waitGroup 成员</h2><p>waitGroup成员是<a href="https://github.com/zixks/nsq-analysis/blob/master/internal/util/wait_group_wrapper.go" target="_blank" rel="noopener">util.WaitGroupWrapper</a>类型,内部组合了sync.WaitGroup类型并绑定Wrap装饰方.用以系统退出时同步关闭tcpServer和httpServer服务进行安全退出.</p><p>在nslookupd.go的入口方法中，装箱tcpserver和httpserver服务<sup><a href="https://github.com/zixks/nsq-analysis/blob/master/nsqlookupd/nsqlookupd.go#L86" target="_blank" rel="noopener">nsqlookupd/nsqlookupd.go:64</a></sup>, 在nslookupd退出时调用Exit()方法<sup><a href="https://github.com/zixks/nsq-analysis/blob/master/nsqlookupd/nsqlookupd.go#L86" target="_blank" rel="noopener">nsqlookupd/nsqlookupd.go:87</a></sup>, 它会等待所有被wrap的方法都执行结束后（调用了wg.done后）进行安全退出.</p><h2 id="四、httpListener成员"><a href="#四、httpListener成员" class="headerlink" title="四、httpListener成员"></a>四、httpListener成员</h2><p>httpListener成员类型定义在<a href="https://github.com/zixks/nsq-analysis/blob/master/nsqlookupd/http.go" target="_blank" rel="noopener">http.go</a>中， 该文件定义httpServer的同时定义了node变量和一个httpServer的工厂方法.httpServer类型包含一个Context上下文类型和一个路由请求处理handler(nsq使用了julienschmidt/httprouter路由，号称最快路由).</p><p>httpServer提供的api接口如下列表，同时它在注册路由时也使用了装饰器http_api.Decorate,装饰了log，http_api等. 同时httpServer提供了大量的DEBUG接口用于系统调试.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">router.Handle(<span class="string">"GET"</span>, <span class="string">"/ping"</span>, http_api.Decorate(s.pingHandler, log, http_api.PlainText))</span><br><span class="line">router.Handle(<span class="string">"GET"</span>, <span class="string">"/info"</span>, http_api.Decorate(s.doInfo, log, http_api.V1))</span><br><span class="line">router.Handle(<span class="string">"GET"</span>, <span class="string">"/debug"</span>, http_api.Decorate(s.doDebug, log, http_api.V1))</span><br><span class="line">router.Handle(<span class="string">"GET"</span>, <span class="string">"/lookup"</span>, http_api.Decorate(s.doLookup, log, http_api.V1))</span><br><span class="line">router.Handle(<span class="string">"GET"</span>, <span class="string">"/topics"</span>, http_api.Decorate(s.doTopics, log, http_api.V1))</span><br><span class="line">router.Handle(<span class="string">"GET"</span>, <span class="string">"/channels"</span>, http_api.Decorate(s.doChannels, log, http_api.V1))</span><br><span class="line">router.Handle(<span class="string">"GET"</span>, <span class="string">"/nodes"</span>, http_api.Decorate(s.doNodes, log, http_api.V1))</span><br><span class="line">router.Handle(<span class="string">"POST"</span>, <span class="string">"/topic/create"</span>, http_api.Decorate(s.doCreateTopic, log, http_api.V1))</span><br><span class="line">router.Handle(<span class="string">"POST"</span>, <span class="string">"/topic/delete"</span>, http_api.Decorate(s.doDeleteTopic, log, http_api.V1))</span><br><span class="line">router.Handle(<span class="string">"POST"</span>, <span class="string">"/channel/create"</span>, http_api.Decorate(s.doCreateChannel, log, http_api.V1))</span><br><span class="line">router.Handle(<span class="string">"POST"</span>, <span class="string">"/channel/delete"</span>, http_api.Decorate(s.doDeleteChannel, log, http_api.V1))</span><br><span class="line">router.Handle(<span class="string">"POST"</span>, <span class="string">"/topic/tombstone"</span>, http_api.Decorate(s.doTombstoneTopicProducer, log, http_api.V1))</span><br><span class="line">router.HandlerFunc(<span class="string">"GET"</span>, <span class="string">"/debug/pprof"</span>, pprof.Index)</span><br><span class="line">router.HandlerFunc(<span class="string">"GET"</span>, <span class="string">"/debug/pprof/cmdline"</span>, pprof.Cmdline)</span><br><span class="line">router.HandlerFunc(<span class="string">"GET"</span>, <span class="string">"/debug/pprof/symbol"</span>, pprof.Symbol)</span><br><span class="line">router.HandlerFunc(<span class="string">"POST"</span>, <span class="string">"/debug/pprof/symbol"</span>, pprof.Symbol)</span><br><span class="line">router.HandlerFunc(<span class="string">"GET"</span>, <span class="string">"/debug/pprof/profile"</span>, pprof.Profile)</span><br><span class="line">router.Handler(<span class="string">"GET"</span>, <span class="string">"/debug/pprof/heap"</span>, pprof.Handler(<span class="string">"heap"</span>))</span><br><span class="line">router.Handler(<span class="string">"GET"</span>, <span class="string">"/debug/pprof/goroutine"</span>, pprof.Handler(<span class="string">"goroutine"</span>))</span><br><span class="line">router.Handler(<span class="string">"GET"</span>, <span class="string">"/debug/pprof/block"</span>, pprof.Handler(<span class="string">"block"</span>))</span><br><span class="line">router.Handler(<span class="string">"GET"</span>, <span class="string">"/debug/pprof/threadcreate"</span>, pprof.Handler(<span class="string">"threadcreate"</span>))</span><br></pre></td></tr></table></figure><p>API接口比较多，功能也都顾名思义比较直接.这儿重点记录几个典型接口实现.</p><h3 id="func-s-httpServer-doCreateTopic"><a href="#func-s-httpServer-doCreateTopic" class="headerlink" title="func(s *httpServer) doCreateTopic"></a>func(s *httpServer) doCreateTopic</h3><p>创建topic接口; 内部实现主要包含了topic参数获取，topic检测，日志记录以及最重要的topic检测. Topic合法检测主要检测了起长度限(internal/protocol/names.go:22)制和一个正则检验(internal/protocol/names.go:8). </p><p>Topic创建通过nsqlookupd的db成员中的AddRegistration方法实现,AddRegistration在实现注册时使用读写锁进行并发资源保护. 代码实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RegistrationDB)</span> <span class="title">AddRegistration</span><span class="params">(k Registration)</span></span> &#123;</span><br><span class="line">r.Lock()</span><br><span class="line"><span class="keyword">defer</span> r.Unlock()</span><br><span class="line">_, ok := r.registrationMap[k]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">r.registrationMap[k] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Producer)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="func-s-httpServer-doLookup"><a href="#func-s-httpServer-doLookup" class="headerlink" title="func (s *httpServer) doLookup"></a>func (s *httpServer) doLookup</h3><p>查询指定Topic的nsqd节点接口(nsqlookupd/http.go:105)，函数内部主要调用了DB变量绑定的方法，从而实现查询功能.</p><p>httpServer提供的api接口方法主要在做与用户交互的一些功能，关于数据的管理都有后端db来提供实现.这也体现了mvc的思路吧算是.</p><h2 id="五、tcpListener-成员"><a href="#五、tcpListener-成员" class="headerlink" title="五、tcpListener 成员"></a>五、tcpListener 成员</h2><p>tcpServer类型定义在tcp.go(nsqlookupd/tcp.go:10)中，函数内部包含一个NSQLookupd的Context变量，以及一个处理请求的方法<code>func Handle(net.Conn)</code>.</p><p>Handle方法主要完成两个操作.</p><h3 id="客户端版本号识别"><a href="#客户端版本号识别" class="headerlink" title="客户端版本号识别"></a>客户端版本号识别</h3><p>调用io.ReadFull读取客户端请求中的版本号，根据该函数描述<code>ReadFull reads exactly len(buf) bytes from r into buf.</code> ，精确读取客户端请求前4字节数据作为客户端版本号. <a href="https://github.com/zixks/nsq-analysis" target="_blank" rel="noopener">当前代码</a>版本仅支持版本号为V1的客户端, 若客户端合法则创建LookupProtocolV1类型并由该类型负责处理消息循环.其他版本则返回<code>E_BAD_PROTOCOL</code></p><h3 id="IOLoop消息循环"><a href="#IOLoop消息循环" class="headerlink" title="IOLoop消息循环"></a><a href="nsqlookupd/lookup_protocol_v1.go:20">IOLoop消息循环</a></h3><p>服务端首先对客户端请求进行预处理，以换行符号‘\n’ 作为请求间的切分标志，并且针对每次请求以空格“ ”分割请求内容作为参数列表. 将请求参数列表和链接对象传给LookupProtocolV1.exec()处理. 根据客户端(nsqd)请求内容的第一个参数，确定请求功能类型.</p><p>IOLoop通过Exec支持四种操作: PING, IDENTIFY, REGISTER UNREGISTER.</p><ul><li><p>PING 心跳包，nsqd存活检测, 并更新nsqd lastUpdate(原子操作)</p></li><li><p>IDENTIFY 主要负责nsqd 连接tcpServer时候发送的注册包，根据nsqd发送的body内容实例化一个PeerInfo用来存储nsqd的meta信息，并讲PeerInfo存储到producer map中.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">peerInfo := PeerInfo&#123;id: client.RemoteAddr().String()&#125;</span><br><span class="line">err = json.Unmarshal(body, &amp;peerInfo)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(err, <span class="string">"E_BAD_BODY"</span>, <span class="string">"IDENTIFY failed to decode JSON body"</span>)</span><br><span class="line">&#125;</span><br><span class="line">peerInfo.RemoteAddress = client.RemoteAddr().String()</span><br><span class="line">...</span><br><span class="line">atomic.StoreInt64(&amp;peerInfo.lastUpdate, time.Now().UnixNano())</span><br></pre></td></tr></table></figure></li><li><p>REGISTER 获取topic channel构造Registration，存储到DB中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p.ctx.nsqlookupd.DB.AddProducer(key, &amp;Producer&#123;peerInfo: client.peerInfo&#125;)&#123;</span><br><span class="line">p.ctx.nsqlookupd.logf(LOG_INFO, <span class="string">"DB: client(%s) REGISTER category:%s key:%s subkey:%s"</span>,client, <span class="string">"channel"</span>, topic, channel)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.ctx.nsqlookupd.DB.AddProducer(key, &amp;Producer&#123;peerInfo: client.peerInfo&#125;)&#123;</span><br><span class="line">p.ctx.nsqlookupd.logf(LOG_INFO, <span class="string">"DB: client(%s) REGISTER category:%s key:%s subkey:%s"</span>,client, <span class="string">"topic"</span>, topic, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UNREGISTER 顾名思义为REGISTER逆操作.</p></li></ul><h2 id="六、DB成员"><a href="#六、DB成员" class="headerlink" title="六、DB成员"></a>六、DB成员</h2><p>DB成员类型定义在nsqlookupd/registration_db.go，该文件中定义以下7中类型，该文件内实现了nsqlookupd的核心业务模型逻辑，tcpServer和httpServer中对外提供的接口都是由该部分提供具体实现.应该算是模型层吧.<br>该部分提供底层操作逻辑供tcpserver&amp;httpserver调用，因此阅读类型结构后根据tcpserver&amp;httpserver作为线索理清楚DB绑定方法.</p><h3 id="DB成员类型依赖关系图"><a href="#DB成员类型依赖关系图" class="headerlink" title="DB成员类型依赖关系图"></a>DB成员类型依赖关系图</h3><img src="/img/nslookupd_type.png"/><h3 id="DB成员提供的服务"><a href="#DB成员提供的服务" class="headerlink" title="DB成员提供的服务"></a>DB成员提供的服务</h3><h4 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h4><p>在RegistrationDB中添加一个Registration key和默认的ProducerMap 并返回false.若已经存在则返回true</p><h4 id="删除Topic"><a href="#删除Topic" class="headerlink" title="删除Topic"></a>删除Topic</h4><p>先根据当前topic检索出该topic上绑定的channels，并删除所有的相关channel（channel也存储在registrationMap中）然后删除该topic相关信息(Producer， PeerInfo…)<br>ps: channel 和 topic都存储在registrationMap中，由key:Registration{Category, Key, SubKey}来区分存储的数据类别.</p><h4 id="屏蔽Topic"><a href="#屏蔽Topic" class="headerlink" title="屏蔽Topic"></a>屏蔽Topic</h4><p><a href="https://github.com/nsqio/nsq/blob/master/nsqlookupd/http.go#L178" target="_blank" rel="noopener">nsqlookupd/http.go:doTombstoneTopicProducer</a>, 屏蔽制定node的一个topic. 在http请求中获取要屏蔽的node和topic,并根据topicName检索出相应的Producer，<a href="https://github.com/nsqio/nsq/blob/master/nsqlookupd/http.go#L198" target="_blank" rel="noopener">根据请求中的node屏蔽Producer中对应的producer</a>. </p><p>虽然go是值传递，for循环时是临时对象，但是根据<code>Producers</code>类型定义可以知道该类型中存储的是指针类型，所以再执行<code>p.Tombstone()</code>时是在具体地址上执行.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Producers []*Producer</span><br></pre></td></tr></table></figure><h4 id="创建Channel"><a href="#创建Channel" class="headerlink" title="创建Channel"></a>创建Channel</h4><p>创建channel步骤与创建topic相同,都是调用AddRegistration，只是在创建channel后调用了一次创建该channel的topic（<a href="https://github.com/nsqio/nsq/blob/master/nsqlookupd/registration_db.go#L76" target="_blank" rel="noopener">不会重复创建</a>）</p><h4 id="删除Channel"><a href="#删除Channel" class="headerlink" title="删除Channel"></a>删除Channel</h4><p>Channel删除比较直接，根据请求中的Channel值，检索出相关Registration然后删除.</p><h4 id="Lookup功能"><a href="#Lookup功能" class="headerlink" title="Lookup功能"></a>Lookup功能</h4><p>根据传入的topic值，检索判断是否存在对应的Registration.检索出相应的producer&amp;channels并返回.</p><h4 id="nsqd连接nsqlookupd-IDENTIFY"><a href="#nsqd连接nsqlookupd-IDENTIFY" class="headerlink" title="nsqd连接nsqlookupd [IDENTIFY]"></a>nsqd连接nsqlookupd <a href="https://github.com/nsqio/nsq/blob/master/nsqlookupd/lookup_protocol_v1.go#L194" target="_blank" rel="noopener">[IDENTIFY]</a></h4><ul><li>解析出请求中peerInfo</li><li>原子操作更新peerInfo.lastUpdate</li><li>注册到Producer</li></ul><p>……</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/mickey0524/nsq-analysis" target="_blank" rel="noopener">[1]nsq源码阅读</a></li><li><a href="https://github.com/zixks/golang-design-pattern/tree/master/00_simple_factory" target="_blank" rel="noopener">[2]go简单工厂模式</a></li><li><a href="https://zh.wikipedia.org/zh-hans/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82" target="_blank" rel="noopener">[3]工厂方法:维基百科</a></li><li><a href="https://github.com/zixks/golang-design-pattern/tree/master/20_decorator" target="_blank" rel="noopener">[4]golang 装饰模式</a> </li><li><a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="noopener">[5]Decorator pattern</a>    </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;blockquote&gt;
&lt;p&gt;NSQ包含三大组件nsqd、nsqlookup、nsqadmin. nsqlookupd 是守护进程负责管理拓扑信息,客户端通过查询 nsqlookupd 来发现指定topic的生产者，并且 nsqd 节点广播topic和
      
    
    </summary>
    
    
      <category term="中间件" scheme="https://blog.yindex.org/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="golang" scheme="https://blog.yindex.org/tags/golang/"/>
    
      <category term="nsq" scheme="https://blog.yindex.org/tags/nsq/"/>
    
      <category term="消息队列" scheme="https://blog.yindex.org/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="nsqlookup" scheme="https://blog.yindex.org/tags/nsqlookup/"/>
    
      <category term="http" scheme="https://blog.yindex.org/tags/http/"/>
    
      <category term="装饰器模式" scheme="https://blog.yindex.org/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>交叉编译nginx-1.14.2 for hisi-arm-linux</title>
    <link href="https://blog.yindex.org/2018/12/28/2018-12-31-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91nginx-1.14.2%20for%20hisi-arm-linux/"/>
    <id>https://blog.yindex.org/2018/12/28/2018-12-31-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91nginx-1.14.2%20for%20hisi-arm-linux/</id>
    <published>2018-12-28T00:32:24.000Z</published>
    <updated>2020-02-26T12:31:13.060Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><blockquote><p>根据别人意见工程架构采用nginx+cgi的架构，当然工程中其他部分也对nginx有所依赖。所以需要把nginx移植到到hisi-arm-linux上。由于nginx自身不具备交叉编译支持，所以需要修改一些配置。</p></blockquote><h2 id="二、交叉编译nginx"><a href="#二、交叉编译nginx" class="headerlink" title="二、交叉编译nginx"></a>二、交叉编译nginx</h2><p>交叉编译环境: ubuntu 18.10 依赖： nginx-1.14.2 pcre-8.42， 仅编译必备选项，其他依赖不进行交叉编译支持（比如ssl） 工具链：aarch64-himix100-linux-gcc configure 配置 </p><pre><code>./configure \--prefix=/root/nfs/nginx/ \ --with-cc=aarch64-himix100-linux-gcc \--with-cpp=aarch64-himix100-linux-g++ \--with-pcre=/home/xxx/nginx/pcre-8.42 \--without-http_gzip_module \--without-http_upstream_zone_module \--sbin-path=/root/nfs/nginx/nginx \--modules-path=/root/nfs/nginx/modules \--conf-path=/root/nfs/nginx/nginx.conf \--error-log-path=/root/nfs/nginx/logs/error.log \--http-log-path=/root/nfs/nginx/logs/access.log \--pid-path=/root/nfs/nginx/run/nginx.pid \--lock-path=/root/nfs/nginx/run/subsys/nginx.lock \</code></pre><p>prefix 安装目录(nfs目录是挂载的网路磁盘) with-cc with-cpp交叉编译工具 with-pcre 是pcre源码路径，不需要单独编译 修改 auto/cc/name </p><pre><code>if [ &quot;$NGX_PLATFORM&quot; != win32 ]; then    ngx_feature=&quot;C compiler&quot;    ngx_feature_name=#    ngx_feature_run=yes    ngx_feature_run=no    ngx_feature_incs=    ngx_feature_path=    ngx_feature_libs=    ngx_feature_test=    . auto/feature    if [ $ngx_found = no ]; then        echo        echo $0: error: C compiler $CC is not found        echo        exit 1    fi  fi</code></pre><p>修改 auto/types/sizeof </p><pre><code>ngx_test=&quot;$CC $CC_TEST_FLAGS $CC_AUX_FLAGS \    ngx_test=&quot;gcc $CC_TEST_FLAGS $CC_AUX_FLAG \if [ -x $NGX_AUTOTEST ]; then    ngx_size=`$NGX_AUTOTEST`       ngx_size=4</code></pre><p>修改auto/options </p><pre><code>140 USE_PCRE=NO141 PCRE=NONE142 PCRE_OPT=143 #PCRE_CONF_OPT=144 PCRE_CONF_OPT=--host=arm-linux145 PCRE_JIT=NO</code></pre><p>修改objs/ngx_auto_config.h， 添加如下语句 </p><pre><code>#ifndef NGX_SYS_NERR#define NGX_SYS_NERR  132#endif#ifndef NGX_HAVE_SYSVSHM#define NGX_HAVE_SYSVSHM 1#endif</code></pre><p>  然后执行make  </p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>  环境搭建完，这才完成1%的工作…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;
&lt;blockquote&gt;
&lt;p&gt;根据别人意见工程架构采用nginx+cgi的架构，当然工程中其他部分也对nginx有所依赖。所以需要把nginx移植到到hisi-arm-linux上。由于nginx自身不具备交叉编译支持，所以需要修改一些配置。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="nginx" scheme="https://blog.yindex.org/categories/nginx/"/>
    
    
      <category term="交叉编译" scheme="https://blog.yindex.org/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
      <category term="海思" scheme="https://blog.yindex.org/tags/%E6%B5%B7%E6%80%9D/"/>
    
      <category term="arm" scheme="https://blog.yindex.org/tags/arm/"/>
    
      <category term="nginx" scheme="https://blog.yindex.org/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>交叉编译 lua for hisi-arm-linux</title>
    <link href="https://blog.yindex.org/2018/12/28/2018-12-28-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%20lua%20for%20hisi-arm-linux/"/>
    <id>https://blog.yindex.org/2018/12/28/2018-12-28-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%20lua%20for%20hisi-arm-linux/</id>
    <published>2018-12-28T00:32:24.000Z</published>
    <updated>2020-02-26T12:31:13.060Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><blockquote><p>最近被借到其他部门做开发, 由于不可抗力因素，项目宿主机器由x64 Ubuntu Server转移到某arm 裸kernel上。为降低机器负载、统一技术栈和其他不可抗力因素后端调度器用C++11重构原有JAVA工程，由C++ with lua实现决策支持引擎。</p></blockquote><h2 id="二、交叉编译lua5-3（ubunt18-10）"><a href="#二、交叉编译lua5-3（ubunt18-10）" class="headerlink" title="二、交叉编译lua5.3（ubunt18.10）"></a>二、<strong>交叉编译lua5.3（ubunt18.10）</strong></h2><p>下载安装交叉编译工具(一般没什么问题，如有问题查看对应交叉编译工具文档) </p><pre><code>cd aarch64-himix100-linuxsudo bash aarch64-himix100-linux.install</code></pre><p>​    </p><p>下载lua5.3源代码,如官网描述，命令行执行下载解压缩 </p><pre><code>curl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gztar zxf lua-5.3.5.tar.gzcd lua-5.3.5/src</code></pre><p>Lua交互式环境中具备查阅历史命令功能，该部分功能由readline实现, 我们在arm仅作为C++扩展脚本使用，因此不需readline.h。 修改源代码屏蔽该库(不然还得交叉编译readline), 我这儿是添加了一个宏用来交叉编译时去掉readline.h, 在lauconf.h 60行添加如下代码 </p><pre><code>#if defined(LUA_USE_ARM)#define LUA_USE_POSIX#define LUA_USE_DLOPEN      /* needs an extra library: -ldl */// 去掉下面这句/*#define LUA_USE_READLINE*/    /* needs some extra libraries */#endif</code></pre><p>修改src/Makefile, 在108（其他位置也行）行添加如下代码, -DLUA_USE_ARM表示lauconf.h这一段启动. </p><pre><code>arm:     $(MAKE) $(ALL) SYSCFLAGS=&quot;-DLUA_USE_ARM&quot; SYSLIBS=&quot;-Wl,-E -ldl&quot;</code></pre><p>修改Makefile第9行，将gcc替换为hisi编译工具 </p><pre><code>#CC= gcc -std=gnu99修改为CC= aarch64-himix100-linux-gcc -std=gnu99</code></pre><p>现在就可以进行编译了, 直接在src目录下执行命令. </p><pre><code>make arm</code></pre><p>如果出现loadlocale.c相关错误,添加环境变量后重新编译 </p><pre><code>export LC_ALL=C</code></pre><p>根据根目录下Makefile可得，抽取部分核心文件:*.h头文件和liblua.a静态链接库 </p><pre><code>42 TO_BIN= lua luac43 TO_INC= lua.h luaconf.h lualib.h lauxlib.h lua.hpp44 TO_LIB= liblua.a45 TO_MAN= lua.1 luac.1</code></pre><p>现在Lua交叉编译完成，可以把上述文件直接copy到hisi-arm-linux上运行使用。 </p><h2 id="三、C-with-lua-test"><a href="#三、C-with-lua-test" class="headerlink" title="三、C++ with lua test"></a>三、<strong>C++ with lua test</strong></h2><p>编写C++&amp;&amp;lua测试代码, 并使用交叉编译工具编译后传到hisi-arm-linux上运行. </p><pre><code>#include &lt;iostream&gt;#include &lt;string.h&gt;  extern &quot;C&quot;{  #include &quot;lua-5.3.5/src/lua.h&quot;    #include &quot;lua-5.3.5/src/lauxlib.h&quot;    #include &quot;lua-5.3.5/src/lualib.h&quot;  }    int main() {    int a, b;  while (std::cin &gt;&gt; a &gt;&gt; b) {    lua_State *L = luaL_newstate();     luaopen_base(L);    luaL_openlibs(L);    luaL_dofile(L, &quot;event.lua&quot;);    lua_getglobal(L, &quot;event&quot;);    lua_pushnumber(L, a);    lua_pushnumber(L, b);    lua_call(L, 2, 0);  }    return 0; }</code></pre><p>​<br>​<br>​    aarch64-himix100-linux-g++  lua.cpp -L lua-5.3.5/src -static -llua -ldl -lm  -o lua_ext<br>​<br>    -lm是链接math库（lua使用）<br>    -L指定链接库位置（交叉编译的arm平台lua库）</p><p>lua代码 </p><pre><code>function event(a, b)  if a + b &lt; 10 then    print(&quot;welcome to C++ with lua regular&quot;)  else        print(&quot;welcome to C++ with lua regular&quot;)  end;  print(&quot;a + b&quot;, a + b)  print(&quot;a * b&quot;, a * b)  print(&quot;a ^ b&quot;, a ^ b)  print(&quot;a / b&quot;, a / b)end;</code></pre><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>作为C++忠实粉丝，强烈抵制某些场景上直接上C++这种重炮, 改换语言能直接提高30%性能的都是自身设计问题. </p><p>lua: 我是一直小小小小鸟～   </p><p>ref </p><ul><li><a href="http://www.lua.org/download.html" target="_blank" rel="noopener">http://www.lua.org/download.html</a></li><li><a href="https://blog.csdn.net/themagickeyjianan/article/details/75301960" target="_blank" rel="noopener">https://blog.csdn.net/themagickeyjianan/article/details/75301960</a> </li><li><a href="https://www.cnblogs.com/wajika/p/6592659.html" target="_blank" rel="noopener">https://www.cnblogs.com/wajika/p/6592659.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;blockquote&gt;
&lt;p&gt;最近被借到其他部门做开发, 由于不可抗力因素，项目宿主机器由x64 Ubuntu Server转移到某arm 裸kernel上。为降低机器负载、统一技术栈和其他不可抗力因素后端调度器用C++11重构原有JAVA工程，由C
      
    
    </summary>
    
    
      <category term="lua" scheme="https://blog.yindex.org/categories/lua/"/>
    
    
      <category term="交叉编译" scheme="https://blog.yindex.org/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
      <category term="lua" scheme="https://blog.yindex.org/tags/lua/"/>
    
      <category term="海思" scheme="https://blog.yindex.org/tags/%E6%B5%B7%E6%80%9D/"/>
    
      <category term="arm" scheme="https://blog.yindex.org/tags/arm/"/>
    
  </entry>
  
  <entry>
    <title>基于CNN的MNIST手写识别尝试</title>
    <link href="https://blog.yindex.org/2017/07/05/%E5%9F%BA%E4%BA%8Ecnn%E8%BF%9B%E8%A1%8Cmnist%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB/"/>
    <id>https://blog.yindex.org/2017/07/05/%E5%9F%BA%E4%BA%8Ecnn%E8%BF%9B%E8%A1%8Cmnist%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB/</id>
    <published>2017-07-05T10:01:09.000Z</published>
    <updated>2020-02-26T12:31:13.064Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h1 id="基于CNN的MNIST手写识别尝试"><a href="#基于CNN的MNIST手写识别尝试" class="headerlink" title="基于CNN的MNIST手写识别尝试"></a>基于CNN的MNIST手写识别尝试</h1><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>MNIST手写识别基本上是深度学习领域的Hello world了，本文主要是使用tensorflow炮筒以下流程，随便添加了几个网络层进行手写识别.</p><h2 id="0x02-CNN网络结构配置"><a href="#0x02-CNN网络结构配置" class="headerlink" title="0x02 CNN网络结构配置"></a>0x02 CNN网络结构配置</h2><h3 id="0x0201-数据预处理"><a href="#0x0201-数据预处理" class="headerlink" title="0x0201 数据预处理"></a>0x0201 数据预处理</h3><p>因为mnist输入数据是一个784维的向量( $28\times28$ ),所以首先通过<code>tf.reshape</code>方法将输入数据转换成(28, 28, 1)的矩阵(width=28，height=28,单通道)</p><h3 id="0x0202-网络结构"><a href="#0x0202-网络结构" class="headerlink" title="0x0202 网络结构"></a>0x0202 网络结构</h3><p>实验目的，网络结构比较简单，主要配置了两个卷基层，两个池化层，一个全连接层.</p><blockquote></blockquote><pre><code>- (3, 3, 1, 1) 卷积- relu6激活函数- max_pool 最大池化- (3, 3, 1, 4) 卷积- relu- max_pool 最大池化- fc 全连接层- dropout 抑制过拟合- softmax 输出 </code></pre><p>卷积层conv2d_1，使用$3\times3$大小的卷积核(vgg就是$3\times3$)进行卷积操作，卷积输出通过relu6激活函数进行激活.这一层输出为(28, 28, 1)<br>对卷积层conv2d_1 输出进行最大池化输出为(14,14,1)<br>卷积层conv2d_2 使用$3\times3$大小卷积核，feature map为4进行卷积操作， 并通过relu函数进行激活， 输出为(14,14, 4)<br>对conv2d_2 进行最大池化，输出为（7， 7, 4)<br>最后对conv2d_2输出进行全连接操作，全连接输出为1024维的特征向量，对该特征向量dropout正则化抑制过拟合. 最后通过softmax产生最终输出.</p><h2 id="0x03-Tensorflow实现"><a href="#0x03-Tensorflow实现" class="headerlink" title="0x03 Tensorflow实现"></a>0x03 Tensorflow实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">权重初始化</span></span><br><span class="line"><span class="string">初始化为一个接近0的很小的正数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    initial = tf.truncated_normal(shape, stddev = <span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    initial = tf.constant(<span class="number">0.1</span>, shape = shape)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(initial)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d</span><span class="params">(x, W)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.conv2d(x, W, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding = <span class="string">'SAME'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pool_2x2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(x, ksize = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                          strides = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding = <span class="string">'SAME'</span>)</span><br><span class="line">    <span class="comment"># tf.nn.max_pool(value, ksize, strides, padding, data_format='NHWC', name=None)</span></span><br><span class="line">    <span class="comment"># x(value)              : [batch, height, width, channels]</span></span><br><span class="line">    <span class="comment"># ksize(pool大小)        : A list of ints that has length &gt;= 4. The size of the window for each dimension of the input tensor.</span></span><br><span class="line">    <span class="comment"># strides(pool滑动大小)   : A list of ints that has length &gt;= 4. The stride of the sliding window for each dimension of the input tensor.</span></span><br><span class="line"></span><br><span class="line">start = time.clock() <span class="comment">#计算开始时间</span></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"MNIST_data/"</span>, one_hot=<span class="literal">True</span>) <span class="comment">#MNIST数据输入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = tf.placeholder(tf.float32,[<span class="literal">None</span>, <span class="number">784</span>])</span><br><span class="line">x_image = tf.reshape(x, [<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>]) <span class="comment">#最后一维代表通道数目，如果是rgb则为3</span></span><br><span class="line">W_conv1 = weight_variable([<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">b_conv1 = bias_variable([<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">h_conv1 = tf.nn.relu6(conv2d(x_image, W_conv1) + b_conv1)</span><br><span class="line"><span class="comment"># x_image -&gt; [batch, in_height, in_width, in_channels]</span></span><br><span class="line"><span class="comment">#            [batch, 28, 28, 1]</span></span><br><span class="line"><span class="comment"># W_conv1 -&gt; [filter_height, filter_width, in_channels, out_channels]</span></span><br><span class="line"><span class="comment">#            [5, 5, 1, 32]</span></span><br><span class="line"><span class="comment"># output  -&gt; [batch, out_height, out_width, out_channels]</span></span><br><span class="line"><span class="comment">#            [batch, 28, 28, 32]</span></span><br><span class="line">h_pool1 = max_pool_2x2(h_conv1)</span><br><span class="line"><span class="comment"># h_conv1 -&gt; [batch, in_height, in_weight, in_channels]</span></span><br><span class="line"><span class="comment">#            [batch, 28, 28, 32]</span></span><br><span class="line"><span class="comment"># output  -&gt; [batch, out_height, out_weight, out_channels]</span></span><br><span class="line"><span class="comment">#            [batch, 14, 14, 32]</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第二层 卷积层</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">h_pool1(batch, 14, 14, 32) -&gt; h_pool2(batch, 7, 7, 64)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">W_conv2 = weight_variable([<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line">b_conv2 = bias_variable([<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)</span><br><span class="line"><span class="comment"># h_pool1 -&gt; [batch, 14, 14, 32]</span></span><br><span class="line"><span class="comment"># W_conv2 -&gt; [5, 5, 32, 64]</span></span><br><span class="line"><span class="comment"># output  -&gt; [batch, 14, 14, 64]</span></span><br><span class="line">h_pool2 = max_pool_2x2(h_conv2)</span><br><span class="line"><span class="comment"># h_conv2 -&gt; [batch, 14, 14, 64]</span></span><br><span class="line"><span class="comment"># output  -&gt; [batch, 7, 7, 64]</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第三层 全连接层</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">h_pool2(batch, 7, 7, 64) -&gt; h_fc1(1, 1024)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">W_fc1 = weight_variable([<span class="number">7</span> * <span class="number">7</span> * <span class="number">4</span>, <span class="number">1024</span>])</span><br><span class="line">b_fc1 = bias_variable([<span class="number">1024</span>])</span><br><span class="line"></span><br><span class="line">h_pool2_flat = tf.reshape(h_pool2, [<span class="number">-1</span>, <span class="number">7</span> * <span class="number">7</span> * <span class="number">4</span>])</span><br><span class="line">h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Dropout</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">h_fc1 -&gt; h_fc1_drop, 训练中启用，测试中关闭</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">keep_prob = tf.placeholder(<span class="string">"float"</span>)</span><br><span class="line">h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第四层 Softmax输出层</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">W_fc2 = weight_variable([<span class="number">1024</span>, <span class="number">10</span>])</span><br><span class="line">b_fc2 = bias_variable([<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y_conv = tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">训练和评估模型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ADAM优化器来做梯度最速下降,feed_dict中加入参数keep_prob控制dropout比例</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">y_ = tf.placeholder(<span class="string">"float"</span>, [<span class="literal">None</span>, <span class="number">10</span>])</span><br><span class="line">cross_entropy = -tf.reduce_sum(y_ * tf.log(y_conv)) <span class="comment">#计算交叉熵</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">"train"</span>):</span><br><span class="line"></span><br><span class="line">    train_step = tf.train.AdamOptimizer(<span class="number">1e-4</span>).minimize(cross_entropy) <span class="comment">#使用adam优化器来以0.0001的学习率来进行微调</span></span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y_conv,<span class="number">1</span>), tf.argmax(y_,<span class="number">1</span>)) <span class="comment">#判断预测标签和实际标签是否匹配</span></span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction,<span class="string">"float"</span>))</span><br><span class="line"></span><br><span class="line">sess = tf.Session() <span class="comment">#启动创建的模型</span></span><br><span class="line">tf.summary.FileWriter(<span class="string">"logs/"</span>, sess.graph)</span><br><span class="line">sess.run(tf.initialize_all_variables()) <span class="comment">#旧版本</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;h1 id=&quot;基于CNN的MNIST手写识别尝试&quot;&gt;&lt;a href=&quot;#基于CNN的MNIST手写识别尝试&quot; class=&quot;headerlink&quot; title=&quot;基于CNN的MNIST手写识别尝试&quot;&gt;&lt;/a&gt;基于CNN的MNIST手写识别尝试&lt;/h1
      
    
    </summary>
    
    
      <category term="深度学习" scheme="https://blog.yindex.org/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="cnn" scheme="https://blog.yindex.org/tags/cnn/"/>
    
      <category term="mnist" scheme="https://blog.yindex.org/tags/mnist/"/>
    
  </entry>
  
</feed>
